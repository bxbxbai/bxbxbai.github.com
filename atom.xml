<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Android Notes</title>
  <subtitle>学会用不同的角度去看待和理解这个世界，你收获的永远比你想象的更多</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bxbxbai.gitcafe.io/"/>
  <updated>2017-07-17T04:04:20.000Z</updated>
  <id>http://bxbxbai.gitcafe.io/</id>
  
  <author>
    <name>bxbxbai</name>
    <email>bxbxbai@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我也来说说Redux</title>
    <link href="http://bxbxbai.gitcafe.io/2017/05/07/talk-about-redux/"/>
    <id>http://bxbxbai.gitcafe.io/2017/05/07/talk-about-redux/</id>
    <published>2017-05-07T06:47:14.000Z</published>
    <updated>2017-07-17T04:04:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>最新有在学习React Native这样的开发框架，其实主要还是想学习一下新的App开发框架和思想。学习React Native已经有一段时间了，并且也开发出了可以用的App（半成品），我最大的一个感受就是，用React Native 开发App的速度非常快，一方面npmjs上已经有非常多的开源库，而且在开发上ES6 也大大的简便了我们的开发</p>
<a id="more"></a>
<p>这篇文章主要是想说一下我在学习React Native中Redux是一个什么样的东西，网上也能搜到非常多的资料，这篇主要是在谈谈我自己的对Redux的理解。</p>
<h2 id="React-Native-里面的Component"><a href="#React-Native-里面的Component" class="headerlink" title="React Native 里面的Component"></a>React Native 里面的Component</h2><p>React Native开发里面<code>Component</code>是一个很重要的东西，我觉得它和Android 里面的<code>Fragment</code>非常类似，是一个带有状态（<code>state</code>）的一个组件，当然还有一个<code>props</code>。在我的理解中，<code>Component</code>是一个由<code>state</code>驱动的组件，就是<code>Component</code>可以根据不同的<code>state</code>来显示不同的View</p>
<p>问题来了，不同的<code>Component</code>之间<code>state</code>都相互独立，不共享的，那么App中有些状态就是统一的，而且只有一个的，比如：用户是否已经登录，或者用户是否是会员或Vip之类的。。。那么像这些状态应该怎么统一维护呢？</p>
<p>有一个办法就是，用户登录成功以后用<code>AsyncStorage</code>来保存用户信息，这种思想是直接源自于App原生开发中的，用一个单例来维护全局的用户信息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//保存用户信息</span></div><div class="line">AsyncStorage.setItem(<span class="string">"_user"</span>, <span class="built_in">JSON</span>.stringify(user));</div><div class="line"></div><div class="line"><span class="comment">//获取用户信息</span></div><div class="line"><span class="keyword">let</span> json = <span class="keyword">await</span> AsyncStorage.getItem(KEY_USER);</div></pre></td></tr></table></figure>
<h2 id="Redux来了"><a href="#Redux来了" class="headerlink" title="Redux来了"></a>Redux来了</h2><p>上面说的方法是“笨”方法，Redux可以非常好的来帮助我们来维护App中的状态。我也不想用别人文章里写过很多的方式来描述Redux，我对于Redux的理解就是，定义里了一套方式来帮助开发者更好的管理React Native应用中的状态，而且是全局状态的维护。</p>
<p>上面说了很多“废话”，<strong>现在来说重点了</strong></p>
<p>首先，要了解Redux，我们必须先了解一下Redux中有哪几部分重要的东西，一共就3种：</p>
<ul>
<li>全局唯一的<code>Store</code>，这只是一个容器</li>
<li><code>Store</code>里面保存的各种状态，需要我们定义<code>Reducers</code>来创建和维护，也就是说<code>Reducers</code>中描述的就是App中的各种状态，这也是最重要的部分</li>
<li>还有各种<code>Actions</code>，就是用来改变<code>Reducers</code>中的状态的</li>
</ul>
<p>总结一下上面说到的3点，用简单的话来描述Redux就是，Redux会帮我们在App中创建一个全局唯一的<code>Store</code>，然后我还需要用<code>reducer</code>来创建各种状态，比如用户的登录状态等等，状态不可能永远不变，比如当用户点击了“登录”按钮，登录成功以后，就需要将<code>Actions</code>以及用户的登录信息发送到<code>Store</code>，<code>Store</code>中的状态就会更新</p>
<p><img src="http://www.sohamkamani.com/assets/images/posts/react-redux-explanation/redux-flow.svg" alt=""></p>
<h3 id="创建和使用Store"><a href="#创建和使用Store" class="headerlink" title="创建和使用Store"></a>创建和使用Store</h3><p>Redux框架已经提供了<code>createStore</code>方法来帮助我们创建一个全局唯一的状态维护容器<code>Store</code>，然后就是使用<code>Store</code>, 使用的时候<strong>必须</strong>要用<code>Provider</code>组件将我们自己写的Component组件包起来，<code>Provider</code>组件还必须要包含一个store 属性（<code>props</code>）将我们创建的<code>Store</code>对象传入。再多说一点，查看源码就明白，<code>Provider</code>组件其实就做了一件非常简单但重要的事情：<strong>将我们创建的Store传给每一个子（Child）组件（Component）</strong>。如下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建Store</span></div><div class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></div><div class="line"><span class="keyword">import</span> &#123;Provider&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</div><div class="line"><span class="keyword">import</span> loginReducer <span class="keyword">from</span> <span class="string">'./reducers'</span></div><div class="line"><span class="keyword">let</span> appStore = createStore(loginReducer)</div><div class="line"></div><div class="line"><span class="comment">//使用Store</span></div><div class="line"><span class="keyword">const</span> AppWithStore = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;appStore&#125;</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> AppWithStore;</div></pre></td></tr></table></figure>
<p>像上面那样使用Store后，我们在<code>App</code>组件中也还是不能使用Redux的store，比如发送Actions或读取Store中的状态。还需要有一点小改动就是，在<code>export App</code>的时候需要用<code>react-redux</code>提供的<code>connect</code>高阶函数来“建立连接”，这是<code>react-redux</code>提供的方便我们写的Component操作和获取Store中的状态。</p>
<p>可以看到下面的代码，<code>connect</code>函数非常奇怪，后面跟了两对括号，其实原理也蛮简单的，就是<code>connect(mapStateToProps, mapDispatchToProps)</code>的返回值也是一个<code>function</code>，并且这个<code>function</code>接受的参数就是一个Component对象。<code>connect</code>函数主要做的事情就是将<code>Component</code>做一次Wrap，对这个好奇的小伙伴可以去看看<code>react-redux</code>框架中的<code>connect.js</code>和<code>connectAdvanced.js</code>文件中的代码</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;connect&#125; from <span class="symbol">'react</span>-redux'</div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">//定义App</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">export <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(<span class="type">App</span>);</div></pre></td></tr></table></figure>
<h3 id="创建reducers"><a href="#创建reducers" class="headerlink" title="创建reducers"></a>创建reducers</h3><p>上面说的创建和使用<code>Store</code>是将Redux如何应用到我们的App中，具体要创建和维护我们需要的App中状态，还需要我们自己来开发reducers。首先，因为在开发过程中会有写很多的Redux，所以最好先新建一个<code>reducers</code>目录，然后分别创建<code>index.js</code> 和 <code>loginRedux.js</code>文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//index.js</span></div><div class="line"><span class="keyword">import</span> &#123;combineReducers&#125; <span class="keyword">from</span> <span class="string">'redux'</span></div><div class="line"><span class="keyword">import</span> loginState <span class="keyword">from</span> <span class="string">'./loginRedux'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> combineReducers(&#123;</div><div class="line">  loginState,</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//loginRedux.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> loginActions = &#123;</div><div class="line">  <span class="attr">LOGIN</span>: <span class="string">'LOGIN'</span>,</div><div class="line">  <span class="attr">LOGOUT</span>: <span class="string">'LOGOUT'</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> initialState = &#123;</div><div class="line">  <span class="attr">login</span>: <span class="literal">false</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params">state = initialState, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">    <span class="keyword">case</span> loginActions.LOGIN: &#123;</div><div class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">login</span>: <span class="literal">true</span>&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">case</span> loginActions.LOGOUT: &#123;</div><div class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">loading</span>: <span class="literal">false</span>&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">return</span> state</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样文件建好以后就可以使用Redux了，可能一开始接触Redux会觉得比较麻烦，一旦基本的框架搭好以后，后面的开发就会变得简单。接下来，可以在<code>LoginPage.js</code>中直接使用了</p>
<ul>
<li>首先把<code>loginRedux</code>的Actions 引用进来，<code>import {loginActions} from &#39;../reducers/loginRedux&#39;</code></li>
<li>然后你就可以直接使用<code>this.props.dispatch({type: loginActions.LOGIN})</code>来更新Store中的login状态</li>
</ul>
<p>这里有两个疑问点：</p>
<ul>
<li>dispatch函数哪里来的？其实这个函数就是一开始我们创建的那个Store对象的，调用<code>dispatch</code>函数就相当于向Store发了一个指令，让Store更新某些状态</li>
<li>Store更新了以后，Component怎么监听到状态改变？答案就是<code>connect</code>函数的参数<code>mapStateToProps</code>，这个函数就相当于告诉Redux，我要监听<code>loginState</code>的变化，而且将Store中的状态<code>loginState</code> 映射（map）到当前Component的props中，字段的名字就叫做<code>loginState</code>（当然你可以改成别的名字）</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const mapStateToProps = (state, props) =&gt; (&#123;</div><div class="line">  loginState: state.loginState,</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="builtin-name">export</span><span class="built_in"> default </span>connect(mapStateToProps)(DailyList);</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对Redux来说，最主要的功能就是帮我们开发JavaScript程序的时候去统一的管理状态（state），提供了流式的状态管理理念，状态（state）被Redux统一保持在一个Store的容器中，如果你要修改Store中的状态，那么你只能通过Store的<code>dispatch</code>函数发送一个Action来修改或更新状态，保证了<strong>单向数据流</strong>。这篇文章主要是将我理解的最本质的Redux用我自己的话描述出来，可能有些地方不一定正确，如果想完整的了解Redux，可以阅读Redux的中文文档：<a href="http://cn.redux.js.org/docs/introduction/CoreConcepts.html" target="_blank" rel="external">http://cn.redux.js.org/docs/introduction/CoreConcepts.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最新有在学习React Native这样的开发框架，其实主要还是想学习一下新的App开发框架和思想。学习React Native已经有一段时间了，并且也开发出了可以用的App（半成品），我最大的一个感受就是，用React Native 开发App的速度非常快，一方面npmjs上已经有非常多的开源库，而且在开发上ES6 也大大的简便了我们的开发&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://bxbxbai.gitcafe.io/tags/Javascript/"/>
    
      <category term="Redux" scheme="http://bxbxbai.gitcafe.io/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>自动检查Android项目dependencies的更新</title>
    <link href="http://bxbxbai.gitcafe.io/2016/08/02/auto-detect-gradle-library/"/>
    <id>http://bxbxbai.gitcafe.io/2016/08/02/auto-detect-gradle-library/</id>
    <published>2016-08-02T09:39:47.000Z</published>
    <updated>2016-08-02T14:31:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用Gradle编译的Android项目中，<code>build.gradle</code>中总会依赖很多第三方库，比如：<code>compile &#39;com.google.code.gson:gson:2.6.2&#39;</code>。而这些第三方库一般的都是在JCenter或MavenCentral上，比如Gson库的网络地址就是：<a href="http://jcenter.bintray.com/com/google/code/gson/gson/" target="_blank" rel="external">http://jcenter.bintray.com/com/google/code/gson/gson/</a>，这个网页上会列出各个可用版本的Gson库。打开那个网页可以发现，最新的可用Gson库是<code>2.7</code></p>
<p>问题来了，如何让Android Studio自动的去检查项目依赖的第三方库是否有更新呢？</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法很简单，就藏在Android Studio里面。首先，打开Android Studio的设置，然后按照下图找到Inspection，选中<strong>Newer Library Version Available</strong>就可以了</p>
<p><img src="/img/newer_library.png" alt=""></p>
<p>然后在Android Studio的菜单<strong>Analyze -&gt; Run Inspections By Name</strong></p>
<p><img src="/img/enter_inspection.png" alt=""></p>
<p>然后，选择你要检查的Module，Android Studio就会自动去检查dependencies的更新，最后就会出现下图：</p>
<p><img src="/img/inspection_results.png" alt=""></p>
<p>最后改写lib的版本号，同步gradle就可以了，是不是很方便！！</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>当然有的人会说，<em>“我可以装一个Android Studio插件来完成这个事情啊”</em>。但是，既然Android Studio中已经存在了这个功能，我为啥还需要一个插件呢？毕竟IDE的插件多了，会影响启动速度的~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Gradle编译的Android项目中，&lt;code&gt;build.gradle&lt;/code&gt;中总会依赖很多第三方库，比如：&lt;code&gt;compile &amp;#39;com.google.code.gson:gson:2.6.2&amp;#39;&lt;/code&gt;。而这些第三方库一般的都是
    
    </summary>
    
    
      <category term="Tips" scheme="http://bxbxbai.gitcafe.io/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>关于Android 6.0 运行时权限</title>
    <link href="http://bxbxbai.gitcafe.io/2016/05/27/android-runtime-permission/"/>
    <id>http://bxbxbai.gitcafe.io/2016/05/27/android-runtime-permission/</id>
    <published>2016-05-27T08:24:21.000Z</published>
    <updated>2016-08-02T10:13:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android 6.0 （API level 23） 已经发布很长一段时间了，其中一个很大的改进就是<strong>运行时权限</strong>。我之前就在知乎回答过一个问题<a href="https://www.zhihu.com/question/37259597/answer/73552786" target="_blank" rel="external">iPhone 到底爽在哪里？</a></p>
<p>我说，iPhone上的App都是默认下载安装的，然后运行App时需要什么权限就弹窗向我申请，这对用户来说就非常好。因为我不想给App权限就不给，而Android 6.0以前是这样的，我下载了一个App安装，系统就弹出这个App需要使用的全部的权限，就给我看一下，我需要这个App 的话，只能同意所有的权限都给这个App，要么我不安装这个App</p>
<p>Android 6.0以前的权限管理应该是我对Android最不满的功能，6.0中 Google终于来解决这个问题了。</p>
<p>下面我就来好好聊聊这个运行时权限管理是怎么回事</p>
<h2 id="权限分类"><a href="#权限分类" class="headerlink" title="权限分类"></a>权限分类</h2><p>在6.0中Android把所有的权限从<strong>逻辑上</strong>分成了两类：<a href="http://developer.android.com/intl/zh-cn/guide/topics/security/permissions.html#normal-dangerous" target="_blank" rel="external">常规（normal）和危险（dangerous）</a></p>
<ul>
<li><strong>常规权限</strong>指的是那些不会直接获取你隐私的权限，如果你在AndroidManifest.xml文件中列出了这些权限的话，系统会自动授权给你。<a href="http://developer.android.com/intl/zh-cn/guide/topics/security/normal-permissions.html" target="_blank" rel="external">这里是normal权限列表</a>，有很多</li>
<li><strong>危险权限</strong>就是那些能获取你隐私信息，或者可能会影响你的文件等的操作。比如读取你的联系人、使用你的摄像头和读取你的日历等等</li>
</ul>
<h3 id="权限组"><a href="#权限组" class="headerlink" title="权限组"></a>权限组</h3><p>这里是危险权限列表：<br><img src="/img/dangerous_permission.png" alt="此处输入图片的描述"></p>
<p>从上图中我们可以看到，Android系统把危险权限分了9大组，这样也是为了简化权限的申请机制。如果你申请了<code>android.permission.READ_CONTACTS</code>读取联系人的权限，<strong>那么6.0 系统就会把这一组中其他的权限也打包给你</strong>。我觉得这个和iOS的隐私管理机制非常相似，在iOS系统设置的“<strong>隐私-&gt;通讯录</strong>”中可以看到，如果你给一个App通讯录的权限，那么这个App既可以读也可以写的</p>
<p><strong>Android 6.0里面只有危险权限才需要运行时获取的</strong></p>
<h2 id="申请权限"><a href="#申请权限" class="headerlink" title="申请权限"></a>申请权限</h2><h3 id="tartgetSdkVersion"><a href="#tartgetSdkVersion" class="headerlink" title="tartgetSdkVersion"></a>tartgetSdkVersion</h3><p>说到申请权限，先要说一下<code>targetSdkVersion</code>这个字段，这个字段一般定义在build.gradle文件中的。这个对App来说很重要！但是是什么意思呢？</p>
<p>假如说<code>targetSdkVersion 22</code>，安装好以后Android系统就知道了这个App在系统API 22以下都测试过了并且能正确运行的，但是在23以上并不可以正确运行的，假如说这个App运行在了Android 6.0系统上，那么Android就会对这个App很“照顾”，兼容它正确运行。比如，6.0系统会把App申请的所有权限都默认给这个App，处理的逻辑和6.0一下的系统是一样的</p>
<h3 id="ActivityCompat"><a href="#ActivityCompat" class="headerlink" title="ActivityCompat"></a>ActivityCompat</h3><p><code>android.support.v4.app.ActivityCompat</code>这个类是App 向系统申请权限主要的工具，而且兼容了各种系统版本</p>
<ul>
<li><code>ActivityCompat.requestPermissions</code>向系统申请一个或一组权限</li>
<li><code>ActivityCompat.checkSelfPermission</code>App检查自己是否有某个权限</li>
<li><code>ActivityCompat.shouldShowRequestPermissionRationale</code>判断弹出对话框中是否含有“不再询问”的选择框</li>
</ul>
<p><img src="/img/request_permission.png" title="undefined" style="
    width: 70%;
"></p>
<p>申请权限的步骤：</p>
<ol>
<li>你要有一个运行Android 6.0系统的设备</li>
<li>将App的<code>targetSdkVersion</code>设置为23</li>
<li>把<code>AndroidManifest.xml</code>中申请的并且是危险的所有权限都列出来，用<code>ActivityCompat.requestPermissions</code>方法向系统申请权限</li>
<li>在所在的Activity中Override<code>onRequestPermissionsResult</code>方法接受系统权限申请的回调</li>
<li>处理回调，比如用户拒绝了某个权限，这时App可以弹出一个对话框描述一下App为何需要这个权限等等</li>
</ol>
<h3 id="targetSdkVersion-小于23"><a href="#targetSdkVersion-小于23" class="headerlink" title="targetSdkVersion 小于23"></a>targetSdkVersion 小于23</h3><p>假如你的App的<code>targetSdkVersion</code>小于23，但是安装到了Android 6.0系统上了，会怎么样呢？会崩溃吗？</p>
<p>别担心，Android开发团队已经考虑到这一点了，如果<code>targetSdkVersion</code>小于23的话，就表示你的App并没有在新的运行时权限系统上测试过，<strong>此时Android系统会把你申请的全部权限都给你</strong>。</p>
<p><strong>但是！！！用户依然可以进入App的设置界面把权限关闭！！</strong></p>
<p><img src="/img/cancel_permission_22.png" alt="cancel permission"></p>
<p>此时你还能用这个权限么？经过我的测试，是不可以了。</p>
<p>所以，如果App的<code>targetSdkVersion</code>小于23并且运行在Android 6.0系统上，怎么去检测用户关闭了权限呢？伟大的stackoverflow告诉我们：<code>android.support.v4.content.PermissionChecker</code>可以帮我们解决这个问题。这个类的文档中有这个一段：</p>
<blockquote>
<p>For apps targeting API lower than <code>android.os.Build.VERSION_CODES.M</code> these permissions are always granted as such apps do not expect permission revocations and would crash. Therefore, when the user disables a permission for a legacy app in the UI the platform disables the APIs guarded by this permission making them a no-op which is doing nothing or returning an empty result or default error.</p>
</blockquote>
<p><code>PermissionChecker.checkSelfPermission</code>方法就是用于检查App自身有没有某一个权限，这个方法的返回结果只有三种：</p>
<ul>
<li><code>PERMISSION_GRANTED</code>: 已授权</li>
<li><code>PERMISSION_DENIED</code>: 没有被授权</li>
<li><code>PERMISSION_DENIED_APP_OP</code>: 没有被授权</li>
</ul>
<p><code>PERMISSION_DENIED</code>和<code>PERMISSION_DENIED_APP_OP</code>都表示没有被授权，但是它们的区别就在于<code>targetSdkVersion</code>的值，如果<code>targetSdkVersion</code>小于23，就返回<code>PERMISSION_DENIED_APP_OP</code>，否则就返回<code>PERMISSION_DENIED</code></p>
<p>因此，如果你的App的<code>targetSdkVersion</code>小于23，但是运行在Android 6.0及以后的系统上，你可以用<code>PermissionChecker.checkSelfPermission(context, permission) == PermissionChecker. PERMISSION_DENIED_APP_OP</code>来检查App是否有某一个权限</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果App的<code>targetSdkVersion</code>小于23（Android 6.0以前），那么<code>ContextCompat#checkSelfPermission</code>和     <code>Context#checkSelfPermission</code>方法的返回结果都是错误的，因为它们总是返回0（<a href="http://developer.android.com/reference/android/content/pm/PackageManager.html#PERMISSION_GRANTED" target="_blank" rel="external">PERMISSION_GRANTED</a>）。即使App运行在Android 6.0上并且用户在设置中关闭了App的权限，上面两个方法返回的结果也是0</p>
<p>上面也说到，Android 6.0系统上，用户是可以关闭App权限的，所以并不是说App的<code>targetSdkVersion</code>小于23就可以不用关心权限问题了：</p>
<ul>
<li>Android &lt; 6.0：系统会给App所有的权限</li>
<li>Android &gt;= 6.0 &amp;&amp; targetSdkVersion &lt; 23：系统会默认给予App所有的权限，但是用户可以去设置中关闭权限。这时你需要使用<code>PermissionChecker.checkSelfPermission</code>来检测App是否有某一个权限</li>
</ul>
<pre><code>public boolean selfPermissionGranted(Context context, String permission) {
    // Android 6.0 以前，全部默认授权
    boolean result = true;

    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {
       if (targetSdkVersion &gt;= Build.VERSION_CODES.M) {
            // targetSdkVersion &gt;= 23, 使用Context#checkSelfPermission
            result = context.checkSelfPermission(permission)
                    == PackageManager.PERMISSION_GRANTED;
        } else {
            // targetSdkVersion &lt; 23, 需要使用 PermissionChecker
            result = PermissionChecker.checkSelfPermission(context, permission)
                    == PermissionChecker.PERMISSION_GRANTED;
        }
    }
    return result;
}
</code></pre><p>获取App的targetSdkVersion值：</p>
<pre><code> try {
    final PackageInfo info = context.getPackageManager().getPackageInfo(
        context.getPackageName(), 0);
    targetSdkVersion = info.applicationInfo.targetSdkVersion;
} catch (PackageManager.NameNotFoundException e) {
    e.printStackTrace();
}
</code></pre><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>不得不说，慢慢的从Android 5.0开始，Google慢慢的缩减了Android开放策略，以前的Android真的是可以为所欲为，监听系统各种变化，甚至一个App被切换到后台，它任然可以获取到当前正在运行的App（用户正在使用的），这个Api可以轻松的获取用户的隐私信息啊，太可怕了。</p>
<p>从Android 6.0开始，运行时权限、Doze模式以及App Standby，Android 7.0中对Doze模式加强，以及取消了很多比如<code>CONNTENCTIVITY_ACTION</code>、<code>ACTION_NEW_PICTURE</code>和<code>ACTION_NEW_VIDEO</code>广播</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://developer.android.com/intl/zh-cn/training/permissions/requesting.html" target="_blank" rel="external">Requesting Permissions at Run Time</a></li>
<li><a href="http://inthecheesefactory.com/blog/things-you-need-to-know-about-android-m-permission-developer-edition" target="_blank" rel="external">Everything every Android Developer must know about new Android’s Runtime Permission</a></li>
<li><a href="http://stackoverflow.com/questions/33407250/checkselfpermission-method-is-not-working-in-targetsdkversion-22" target="_blank" rel="external">checkSelfPermission method is not working in targetSdkVersion 22</a></li>
<li><a href="https://mssun.me/blog/android-4-3-app-ops-analysis.html" target="_blank" rel="external">Android 4.3 隐藏功能 App Ops 分析</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android 6.0 （API level 23） 已经发布很长一段时间了，其中一个很大的改进就是&lt;strong&gt;运行时权限&lt;/strong&gt;。我之前就在知乎回答过一个问题&lt;a href=&quot;https://www.zhihu.com/question/37259597/a
    
    </summary>
    
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>ButterKnife框架原理</title>
    <link href="http://bxbxbai.gitcafe.io/2016/03/12/how-butterknife-works/"/>
    <id>http://bxbxbai.gitcafe.io/2016/03/12/how-butterknife-works/</id>
    <published>2016-03-12T06:25:46.000Z</published>
    <updated>2016-03-13T06:17:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>大部分Android开发应该都知道<a href="https://twitter.com/jakewharton" target="_blank" rel="external">@JakeWharton</a> 大神的<strong>ButterKnife</strong>注解库，使用这个库我们可以不用写很多无聊的<code>findViewById()</code>和<code>setOnClickListener()</code>等代码</p>
<a id="more"></a>
<p><strong>ButterKnife</strong>项目的主页在这里：<a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="external">http://jakewharton.github.io/butterknife/</a> 简单介绍一下使用方法：</p>
<pre><code>public class ExampleActivity extends Activity {
      @Bind(R.id.title) EditText titleView;
      @Bind(R.id.subtitle) EditText subtitleView;

      @Override protected void onCreate(Bundle savedInstanceState) {
       super.onCreate(savedInstanceState);
       setContentView(R.layout.example_activity);
       ButterKnife.bind(this);
     }
   }
</code></pre><p>但是这个库是如何工作的呢？可能很多人都觉得ButterKnife在<code>bind(this)</code>方法执行的时候通过反射获取<code>ExampleActivity</code>中所有的带有<code>@Bind</code>注解的属性并且获得注解中的<code>R.id.xxx</code>值，最后还是通过反射拿到<code>Activity.findViewById()</code>方法获取View，并赋值给<code>ExampleActivity</code>中的某个属性</p>
<p>这是一个注解库的实现方式，比较原始，一个很大的缺点就是在Activity运行时大量使用反射会影响App的运行性能，造成卡顿以及生成很多临时Java对象更容易触发GC</p>
<p><code>ButterKnife</code>显然没有使用这种方式，它用了Java Annotation Processing技术，就是在Java代码编译成Java字节码的时候就已经处理了<code>@Bind</code>、<code>@OnClick</code>（ButterKnife还支持很多其他的注解）这些注解了</p>
<h2 id="Java-Annotation-Processing"><a href="#Java-Annotation-Processing" class="headerlink" title="Java Annotation Processing"></a>Java Annotation Processing</h2><blockquote>
<p>Annotation processing 是javac中用于编译时扫描和解析Java注解的工具</p>
</blockquote>
<p>你可以你定义注解，并且自己定义解析器来处理它们。Annotation processing是在编译阶段执行的，它的原理就是读入Java源代码，解析注解，然后生成新的Java代码。新生成的Java代码最后被编译成Java字节码，注解解析器（Annotation Processor）不能改变读入的Java 类，比如不能加入或删除Java方法</p>
<p>下图是Java 编译代码的整个过程，可以帮助我们很好理解注解解析的过程：</p>
<p><img src="/img/java_compiler.png" alt=""></p>
<h2 id="ButterKnife-工作流程"><a href="#ButterKnife-工作流程" class="headerlink" title="ButterKnife 工作流程"></a>ButterKnife 工作流程</h2><p>当你编译你的Android工程时，ButterKnife工程中<code>ButterKnifeProcessor</code>类的<code>process()</code>方法会执行以下操作：</p>
<ul>
<li>开始它会扫描Java代码中所有的ButterKnife注解<code>@Bind</code>、<code>@OnClick</code>、<code>@OnItemClicked</code>等</li>
<li>当它发现一个类中含有任何一个注解时，<code>ButterKnifeProcessor</code>会帮你生成一个Java类，名字类似<code>&lt;className&gt;$$ViewBinder</code>，这个新生成的类实现了<code>ViewBinder&lt;T&gt;</code>接口</li>
<li>这个<code>ViewBinder</code>类中包含了所有对应的代码，比如<code>@Bind</code>注解对应<code>findViewById()</code>, <code>@OnClick</code>对应了<code>view.setOnClickListener()</code>等等</li>
<li>最后当Activity启动<code>ButterKnife.bind(this)</code>执行时，ButterKnife会去加载对应的<code>ViewBinder</code>类调用它们的<code>bind()</code>方法</li>
</ul>
<h2 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h2><p>一段Java代码：</p>
<pre><code>class ExampleActivity extends Activity {
     @Bind(R.id.user) EditText username;
     @Bind(R.id.pass) EditText password;

    @Override public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.simple_activity);
         ButterKnife.bind(this);
         // TODO Use fields…
     }

     @OnClick(R.id.submit) void submit() {
     // TODO call server…
     }
}
</code></pre><p>编译成功后，下面的代码生成了：</p>
<pre><code>public class ExampleActivity$$ViewBinder&lt;T extends 
        io.bxbxbai.samples.ui.ExampleActivity&gt; implements ViewBinder&lt;T&gt; {

     @Override public void bind(final Finder finder, final T target, Object source) {
          View view;
          view = finder.findRequiredView(source, 21313618, “field ‘user’”);
          target.username = finder.castView(view, 21313618, “field ‘user’”);
          view = finder.findRequiredView(source, 21313618, “field ‘pass’”);
          target.password = finder.castView(view, 21313618, “field ‘pass’”);
          view = finder.findRequiredView(source, 21313618, “field ‘submit’ and method ‘submit’”);
          view.setOnClickListener(
            new butterknife.internal.DebouncingOnClickListener() {
               @Override public void doClick(android.view.View p0) {
      target.submit();
           }
        });
      }

     @Override public void reset(T target) {
           target.username = null;
           target.password = null;
     }
}
</code></pre><p>用一张图来说明一下：</p>
<p><img src="/img/butterknife_example.png" alt=""></p>
<h2 id="ButterKnife-bind-执行阶段"><a href="#ButterKnife-bind-执行阶段" class="headerlink" title="ButterKnife.bind 执行阶段"></a>ButterKnife.bind 执行阶段</h2><p>最后，执行<code>bind</code>方法时，我们会调用<code>ButterKnife.bind(this)</code>：</p>
<ul>
<li>ButterKnife会调用<code>findViewBinderForClass(targetClass)</code>加载<code>ExampleActivity$$ViewBinder.java</code>类</li>
<li>然后调用<code>ViewBinder</code>的<code>bind</code>方法，动态注入<code>ExampleActivity</code>类中所有的View属性和</li>
<li>如果Activity中有<code>@OnClick</code>注解的方法，ButterKnife会在<code>ViewBinder</code>类中给View设置onClickListener，并且将<code>@OnClick</code>注解的方法传入其中</li>
</ul>
<p>在上面的过程中可以看到，为什么你用<code>@Bind</code>、<code>@OnClick</code>等注解标注的属性或方法必须是public或protected的，因为ButterKnife是通过<code>ExampleActivity.this.editText</code>来注入View的</p>
<p>为什么要这样呢？有些注入框架比如roboguice你是可以把View设置成private的，答案就是<strong>性能</strong>。如果你把View设置成private，那么框架必须通过反射来注入View，不管现在手机的CPU处理器变得多快，如果有些操作会影响性能，那么是肯定要避免的，这就是ButterKnife与其他注入框架的不同</p>
<h2 id="有一点需要注意"><a href="#有一点需要注意" class="headerlink" title="有一点需要注意"></a>有一点需要注意</h2><p>通过ButterKnife来注入View时，ButterKnife有<code>bind(Object, View)</code> 和 <code>bind(View)</code>两个方法，有什么区别呢？</p>
<p>如果你自定义了一个View，比如<code>public class BadgeLayout extends Fragment</code>，那么你可以可以通过<code>ButterKnife.bind(BadgeLayout)</code>来注入View的</p>
<p>如果你在一个ViewHolder中inflate了一个xml布局文件，得到一个<code>View</code>对象，并且这个View是<code>LinearLayout</code>或<code>FrameLayout</code>等系统自带View，那么不是不能用<code>ButterKnife.bind(View)</code>来注入View的，因为ButterKnife认为这些类的包名以<code>com.android</code>开头的类是没有注解功能的（-。- 这不是废话吗？），所以这种情况你需要使用<code>ButterKnife.bind(ViewHolder，View)</code>来注入View。</p>
<p>这表示<strong>你是把<code>@Bind</code>、<code>@OnClick</code>等注解写到了这个ViewHolder类中，ViewHolder中的View呢需要从后面那个<code>View</code>中去找</strong>， 大概就是这么个意思</p>
<p>参考：<a href="https://medium.com/@lgvalle/how-butterknife-actually-works-85be0afbc5ab" target="_blank" rel="external">https://medium.com/@lgvalle/how-butterknife-actually-works-85be0afbc5ab</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大部分Android开发应该都知道&lt;a href=&quot;https://twitter.com/jakewharton&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@JakeWharton&lt;/a&gt; 大神的&lt;strong&gt;ButterKnife&lt;/strong&gt;注解库，使用这个库我们可以不用写很多无聊的&lt;code&gt;findViewById()&lt;/code&gt;和&lt;code&gt;setOnClickListener()&lt;/code&gt;等代码&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit2 源码解析</title>
    <link href="http://bxbxbai.gitcafe.io/2015/12/13/retrofit2/"/>
    <id>http://bxbxbai.gitcafe.io/2015/12/13/retrofit2/</id>
    <published>2015-12-13T05:16:29.000Z</published>
    <updated>2016-03-12T06:55:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>公司里最近做的项目中网络框架用的就是<a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit</a>，用的多了以后觉得这个框架真的非常好用，然后抽了点时间debug了一下源码，觉得不光代码写的非常好，而且设计这个框架的思路都非常特别，收获很多，决定记录下来</p>
<p><strong>本文的源码分析基于Retrofit 2.0，和Retrofit 1.0有较大的不同</strong>， 本文主要分为几部分：0、Retrofi 是什么，1、Retrofi怎么用，2、Retrofit的原理是什么，3、我的心得与看法</p>
<p><strong>下面说的Retrofit全部指Retrofit 2</strong></p>
<a id="more"></a>
<h2 id="0-Retrofit是什么"><a href="#0-Retrofit是什么" class="headerlink" title="0 Retrofit是什么"></a>0 Retrofit是什么</h2><p>来自Retrofit官网的介绍：</p>
<blockquote>
<p>A type-safe HTTP client for Android and Java</p>
</blockquote>
<p>简单的说它是一个HTTP请求工具，和Google开发的Volley功能上非常相似，这里有<a href="http://bxbxbai.github.io/2014/12/24/read-volley-source-code/" target="_blank" rel="external">Volley的源码解析</a>，但是使用上很不相似。Retrofit使用起来更简单，Volley使用上更加原始而且符合使用者的直觉，其实我觉得如果对自己Volley封装一下也可以像Retrofit那样的简单的使用</p>
<p>关于Volley的使用方法，请戳上面的Volley源码解析链接，这里就不赘述了</p>
<h2 id="1-Retrofit怎么用"><a href="#1-Retrofit怎么用" class="headerlink" title="1 Retrofit怎么用"></a>1 Retrofit怎么用</h2><p>虽然Retrofit官网已经说明了，我还是要按照我的思路说一下它的使用方法</p>
<p>比如你要请求这么一个api：</p>
<blockquote>
<p><a href="https://api.github.com/repos/{owner}/{repo}/contributors" target="_blank" rel="external">https://api.github.com/repos/{owner}/{repo}/contributors</a></p>
</blockquote>
<p>查看github上某个repo的contributors，首先你要这样建一个接口：</p>
<pre><code>public interface GitHub {
    @GET(&quot;/repos/{owner}/{repo}/contributors&quot;)
    Call&lt;List&lt;Contributor&gt;&gt; contributors(
        @Path(&quot;owner&quot;) String owner,
        @Path(&quot;repo&quot;) String repo);
}
</code></pre><p>然后你还需要创建一个<code>Retrofit</code>对象：</p>
<pre><code>public static final String API_URL = &quot;https://api.github.com&quot;;

// Create a very simple REST adapter which points the GitHub API.
Retrofit retrofit = new Retrofit.Builder()
    .baseUrl(API_URL)
    .addConverterFactory(GsonConverterFactory.create())
    .build();
</code></pre><p>再用这个<code>Retrofit</code>对象创建一个<code>GitHub</code>对象：</p>
<pre><code>// Create an instance of our GitHub API interface.
GitHub github = retrofit.create(GitHub.class);

// Create a call instance for looking up Retrofit contributors.
Call&lt;List&lt;Contributor&gt;&gt; call = github.contributors(&quot;square&quot;, &quot;retrofit&quot;);
</code></pre><p>最后你就可以用这个<code>Githb</code>对象获得数据了：</p>
<pre><code>// Fetch and print a list of the contributors to the library.
call.enqueue(new Callback&lt;List&lt;Contributor&gt;&gt;() {
    @Override
    public void onResponse(Response&lt;List&lt;Contributor&gt;&gt; response) {
        for (Contributor contributor : response.body()) {
            System.out.println(contributor.login + &quot; (&quot; + contributor.contributions + &quot;)&quot;);
        }
    }
    @Override
    public void onFailure(Throwable t) {
    }
});
</code></pre><p>这个使用方式看上去和Volley的方式完全不一样，使用Volley时你必须先创建一个<code>Request</code>对象，包括这个请求的Method，Url，Url的参数，以及一个请求成功和失败的Listener，然后把这个请求放到<code>RequestQueue</code>中，最后NetworkDispatcher会请求服务器获得数据。而<code>Retrofit</code>只要创建一个接口就可以了，太不可思议了！！</p>
<p>而我要说，其实这两种方式本质上是一样的，只是这个框架<strong>描述HTTP请求的方式不一样而已</strong>。因此，<strong>你可以发现上面的<code>Github</code>接口其实就是<code>Retrofit</code>对一个HTTP请求的描述</strong></p>
<h1 id="2-Retrofit的原理"><a href="#2-Retrofit的原理" class="headerlink" title="2 Retrofit的原理"></a>2 Retrofit的原理</h1><p>Volley描述一个HTTP请求是需要创建一个<code>Request</code>对象，而执行这个请求呢，就是把这个请求对象放到一个队列中，让网络线程去处理。</p>
<p>Retrofit是怎么做的呢？答案就是<strong>Java的动态代理</strong></p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>当开始看Retrofit的代码，我对下面这句代码感到很困惑：</p>
<pre><code>// Create an instance of our GitHub API interface.
GitHub github = retrofit.create(GitHub.class);
</code></pre><p>我给Retrofit对象传了一个<code>Github</code>接口的Class对象，怎么又返回一个<code>Github</code>对象呢？进入<code>create</code>方法一看，没几行代码，但是我觉得这几行代码就是Retrofit的精妙的地方：</p>
<pre><code>/** Create an implementation of the API defined by the {@code service} interface. */
@SuppressWarnings(&quot;unchecked&quot;) // Single-interface proxy creation guarded by parameter safety.
public &lt;T&gt; T create(final Class&lt;T&gt; service) {
  Utils.validateServiceInterface(service);
  if (validateEagerly) {
      eagerlyValidateMethods(service);
  }
  return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service },
    new InvocationHandler() {
      private final Platform platform = Platform.get();
      @Override public Object invoke(Object proxy, Method method, Object... args)
          throws Throwable {
        // If the method is a method from Object then defer to normal invocation.
        if (method.getDeclaringClass() == Object.class) {
          return method.invoke(this, args);
        }
        if (platform.isDefaultMethod(method)) {
          return platform.invokeDefaultMethod(method, service, proxy, args);
        }
        return loadMethodHandler(method).invoke(args);
      }
    });
}
</code></pre><p>看，<code>create</code>方法重要就是返回了一个动态代理对象。那么问题来了…</p>
<p><strong>动态代理是个什么东西？</strong></p>
<p>看Retrofit代码之前我知道Java动态代理是一个很重要的东西，比如在Spring框架里大量的用到，但是它有什么用呢？</p>
<p><strong>Java动态代理就是Java开发给了开发人员一种可能：当你要调用某个类的方法前，插入你想要执行的代码</strong></p>
<p>比如你要执行某个操作前，你必须要判断这个用户是否登录，或者你在付款前，你需要判断这个人的账户中存在这么多钱。这么简单的一句话，我相信可以把一个不懂技术的人也讲明白Java动态代理是什么东西了。</p>
<h2 id="为什么要使用动态代理"><a href="#为什么要使用动态代理" class="headerlink" title="为什么要使用动态代理"></a>为什么要使用动态代理</h2><p>你看上面代码，获取数据的代码就是这句:</p>
<pre><code>// Create a call instance for looking up Retrofit contributors.
Call&lt;List&lt;Contributor&gt;&gt; call = github.contributors(&quot;square&quot;, &quot;retrofit&quot;);
</code></pre><p>上面<code>github</code>对象其实是一个动态代理对象，并不是一个真正的<code>Githb</code>接口的<code>implements</code>对象，当<code>github</code>对象调用<code>contributors</code>方法时，执行的是动态代理方法（你debug一下就知道了）</p>
<p>此时，动态代理发挥了它的作用，你看上去是调用了<code>contributors</code>方法，其实此时Retrofit把<code>Github</code>接口翻译成一个HTTP请求，也就是Retrofit中的<code>MethodHandler</code>对象，这个对象中包含了：</p>
<ul>
<li>OkHttpClient：发送网络请求的工具</li>
<li>RequestFactory： 类似于Volley中的<code>Request</code>，包含了HTTP请求的Url、Header信息，MediaType、Method以及RequestAction数组</li>
<li>CallAdapter：HTTP请求返回数据的类型</li>
<li>Converter：数据转换器</li>
</ul>
<p>嗯，简单来说，Retrofit就是在你调用<code>Call&lt;List&lt;Contributor&gt;&gt; call = github.contributors(&quot;square&quot;, &quot;retrofit&quot;);</code>后为你生成了一个Http请求，然后，你调用<code>call.enqueue</code>方法时就发送了这个请求，然后你就可以处理Response的数据了，从原理上讲，就是这样的。如果要再往细节处说，就可以再说很多了</p>
<h1 id="3-Retrofit的源码分析"><a href="#3-Retrofit的源码分析" class="headerlink" title="3 Retrofit的源码分析"></a>3 Retrofit的源码分析</h1><p>想要弄清楚Retrofit的细节，先来看一下Retrofit源码的组成：</p>
<ol>
<li>一个<code>retrofit2.http</code>包，里面全部是定义HTTP请求的注解，比如<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>、<code>Headers</code>、<code>Path</code>、<code>Query</code>等等</li>
<li>余下的<code>retrofit2</code>包中十几个类和接口就是全部retrofit的代码了，代码真的很少，很简单，因为retrofit把网络请求这部分功能全部交给了okHttp了</li>
</ol>
<h2 id="Retrofit接口"><a href="#Retrofit接口" class="headerlink" title="Retrofit接口"></a>Retrofit接口</h2><p>我觉得你你必须要知道下面接口的含义</p>
<h3 id="Callback-lt-T-gt"><a href="#Callback-lt-T-gt" class="headerlink" title="Callback&lt;T&gt;"></a><code>Callback&lt;T&gt;</code></h3><p>这个接口就是retrofit请求数据返回的接口，只有两个方法</p>
<ul>
<li><code>void onResponse(Response&lt;T&gt; response);</code></li>
<li><code>void onFailure(Throwable t);</code></li>
</ul>
<h3 id="Converter-lt-F-T-gt"><a href="#Converter-lt-F-T-gt" class="headerlink" title="Converter&lt;F, T&gt;"></a><code>Converter&lt;F, T&gt;</code></h3><p>这个接口主要的作用就是将HTTP返回的数据解析成Java对象，主要由Xml、Gson、protobuf等等，你可以在创建<code>Retrofit</code>对象时添加你需要使用的<code>Converter</code>实现（看上面创建Retrofit对象的代码）</p>
<h3 id="Call-lt-T-gt"><a href="#Call-lt-T-gt" class="headerlink" title="Call&lt;T&gt;"></a><code>Call&lt;T&gt;</code></h3><p>这个接口主要的作用就是发送一个HTTP请求，Retrofit默认的实现是<code>OkHttpCall&lt;T&gt;</code>，你可以根据实际情况实现你自己的Call类，这个设计和Volley的<code>HttpStack</code>接口设计的思想非常相似，子类可以实现基于<code>HttpClient</code>或<code>HttpUrlConnetction</code>的HTTP请求工具，<strong>这种设计非常的插件化，而且灵活</strong></p>
<h3 id="CallAdapter-lt-T-gt"><a href="#CallAdapter-lt-T-gt" class="headerlink" title="CallAdapter&lt;T&gt;"></a><code>CallAdapter&lt;T&gt;</code></h3><p>上面说到过，<code>CallAdapter</code>中属性只有<code>responseType</code>一个，还有一个<code>&lt;R&gt; T adapt(Call&lt;R&gt; call)</code>方法，这个接口的实现类也只有一个，<code>DefaultCallAdapter</code>。这个方法的主要作用就是将<code>Call</code>对象转换成另一个对象，可能是为了支持RxJava才设计这个类的吧</p>
<h2 id="Retrofit的运行"><a href="#Retrofit的运行" class="headerlink" title="Retrofit的运行"></a>Retrofit的运行</h2><p>刚才讲到<code>GitHub github = retrofit.create(GitHub.class);</code>代码返回了一个动态代理对象，而执行<code>Call&lt;List&lt;Contributor&gt;&gt; call = github.contributors(&quot;square&quot;, &quot;retrofit&quot;);</code>代码时返回了一个<code>OkHttpCall</code>对象，拿到这个<code>Call</code>对象才能执行HTTP请求</p>
<p>其中后一句代码执行了一个非常复杂的过程</p>
<p>当执行了<code>contributors</code>方法时，Retrofit其实是执行了动态代理的<code>InvocationHandler</code>对象，最后会创建一个<code>MethodHandler</code>对象，这个对象很重要</p>
<pre><code>static MethodHandler&lt;?&gt; create(Retrofit retrofit, Method method) {
    CallAdapter&lt;Object&gt; callAdapter = (CallAdapter&lt;Object&gt;) createCallAdapter(method, retrofit);
    Type responseType = callAdapter.responseType();
    Converter&lt;ResponseBody, Object&gt; responseConverter =
        (Converter&lt;ResponseBody, Object&gt;) createResponseConverter(method, retrofit, responseType);
    RequestFactory requestFactory = RequestFactoryParser.parse(method, responseType, retrofit);

    return new MethodHandler&lt;&gt;(retrofit.client(), requestFactory, callAdapter, responseConverter);
}
</code></pre><p>上面代码就是创建一个<code>MethodHandler</code>对象，一个<code>MethodHandler</code>对象中包含了4个对象</p>
<h3 id="0-OkHttpClient"><a href="#0-OkHttpClient" class="headerlink" title="0. OkHttpClient"></a>0. OkHttpClient</h3><p>这个是Retrofit默认生成的</p>
<h3 id="1-RequestFactory："><a href="#1-RequestFactory：" class="headerlink" title="1. RequestFactory："></a>1. RequestFactory：</h3><p>通过<code>RequestFactoryParser.parse(method, responseType, retrofit);</code>生成，主要作用就是<strong>解析整个Http请求的所有数据</strong></p>
<p>主要原理就是解析一个接口，比如上面的<code>Github</code>接口，结果就是得到整个Http请求全部的信息，还会通过<code>@Path</code>和<code>@Query</code>注解拼接Url</p>
<p>不细讲了，全部代码都在<code>retrofit.RequestFactoryParser</code>类中</p>
<h3 id="2-CallAdapter"><a href="#2-CallAdapter" class="headerlink" title="2. CallAdapter"></a>2. CallAdapter</h3><p>获取<code>CallAdapter</code>的代码如下：</p>
<pre><code>private static CallAdapter&lt;?&gt; createCallAdapter(Method method, Retrofit retrofit) {
  Type returnType = method.getGenericReturnType();
  if (Utils.hasUnresolvableType(returnType)) {
    throw Utils.methodError(method,
      &quot;Method return type must not include a type variable or wildcard: %s&quot;, returnType);
  }
  if (returnType == void.class) {
    throw Utils.methodError(method, &quot;Service methods cannot return void.&quot;);
  }
  Annotation[] annotations = method.getAnnotations();
  try {
    return retrofit.callAdapter(returnType, annotations);
  } catch (RuntimeException e) { // Wide exception range because factories are user code.
    throw Utils.methodError(e, method, &quot;Unable to create call adapter for %s&quot;, returnType);
  }
}
</code></pre><p>你可以在创建Retrofit对象时，添加你想要的<code>CallAdapter</code>，而获取<code>CallAdapter</code>的方式也是从<code>Retrofit</code>对象中获取</p>
<p>默认的<code>DefaultCallAdapter</code>几乎没有上面作用，基本和动画里面的<code>LinearInterpolator</code>差不多</p>
<h3 id="3-Converter"><a href="#3-Converter" class="headerlink" title="3. Converter"></a>3. Converter</h3><p>获得<code>Converter</code>对象和上面的原理几乎一样</p>
<pre><code>private static Converter&lt;ResponseBody, ?&gt; createResponseConverter(Method method,
  Retrofit retrofit, Type responseType) {
  Annotation[] annotations = method.getAnnotations();
  try {
    return retrofit.responseBodyConverter(responseType, annotations);
  } catch (RuntimeException e) { // Wide exception range because factories are user code.
    throw Utils.methodError(e, method, &quot;Unable to create converter for %s&quot;, responseType);
  }
}
</code></pre><p>创建这4个对象的目的就是为了执行下面这句代码</p>
<pre><code>Object invoke(Object... args) {
  return callAdapter.adapt(new OkHttpCall&lt;&gt;(client, requestFactory, responseConverter, args));
}
</code></pre><p>这个也就是<code>github.contributors(&quot;square&quot;, &quot;retrofit&quot;);</code>返回的<code>Call</code>对象</p>
<p>最后你调用<code>Call</code>对象的<code>execute()</code>或<code>enqueue(Callback&lt;T&gt; callback)</code>方法，就能发送一个Http请求了</p>
<p>只不过前一种方式是同步的，后一种是异步的，<strong>也就是说Retrofit提供了同步和异步两种HTTP请求方式</strong></p>
<p>你可能会觉得我只要发送一个HTTP请求，你要做这么多事情不会很“慢”吗？不会很浪费性能吗？</p>
<p>我觉得，首先现在手机处理器主频非常高了，解析这个接口可能就花1ms可能更少的时间（我没有测试过），面对一个HTTP本来就需要几百ms，甚至几千ms来说不值得一提；而且Retrofit会对解析过的请求进行缓存，就在<code>Map&lt;Method, MethodHandler&lt;?&gt;&gt; methodHandlerCache</code>这个对象中</p>
<h2 id="如何在Retrofit中使用RxJava"><a href="#如何在Retrofit中使用RxJava" class="headerlink" title="如何在Retrofit中使用RxJava"></a>如何在Retrofit中使用RxJava</h2><p>由于Retrofit设计的扩张性非常强，你只需要改变一下<code>CallAdapter</code>就可以了</p>
<p>  Retrofit retrofit = new Retrofit.Builder()<br>      .baseUrl(“<a href="https://api.github.com" target="_blank" rel="external">https://api.github.com</a>“)<br>      .addConverterFactory(ProtoConverterFactory.create())<br>      .addConverterFactory(GsonConverterFactory.create())<br>      .addCallAdapterFactory(RxJavaCallAdapterFactory.create())<br>      .build();</p>
<p>上面代码创建了一个<code>Retrofit</code>对象，支持Proto和Gson两种数据格式，并且还支持RxJava</p>
<h1 id="4-最后"><a href="#4-最后" class="headerlink" title="4 最后"></a>4 最后</h1><p><strong>Retrofit非常巧妙的用注解来描述一个HTTP请求，将一个HTTP请求抽象成一个Java接口，然后用了Java动态代理的方式，动态的将这个接口的注解“翻译”成一个HTTP请求，最后再执行这个HTTP请求</strong></p>
<p>Retrofit的功能非常多的依赖Java反射，代码中其实还有很多细节，比如异常的捕获、抛出和处理，大量的Factory设计模式（为什么要这么多使用Factory模式？）</p>
<p>Retrofit中接口设计的恰到好处，在你创建<code>Retrofit</code>对象时，让你有更多更灵活的方式去处理你的需求，比如使用不同的<code>Converter</code>、使用不同的<code>CallAdapter</code>，这也就提供了你使用RxJava来调用Retrofit的可能</p>
<p>我也慢慢看了<a href="http://square.github.io/picasso/" target="_blank" rel="external"><code>Picasso</code></a>和<code>Retrofit</code>的代码了，收获还是很多的，也更加深入的理解面向接口的编程方法，这个写代码就是<strong>好的代码就是依赖接口而不是实现</strong>最好的例子</p>
<p>好感谢开源的世界，让我能读到大牛的代码。我一直觉得一个人如果没有读过好的代码是不太可能写出好代码的。什么是好的代码？像<code>Picasso</code>和<code>Retrofit</code>这样的就是好的代码，扩展性强、低耦合、插件化</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司里最近做的项目中网络框架用的就是&lt;a href=&quot;http://square.github.io/retrofit/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Retrofit&lt;/a&gt;，用的多了以后觉得这个框架真的非常好用，然后抽了点时间debug了一下源码，觉得不光代码写的非常好，而且设计这个框架的思路都非常特别，收获很多，决定记录下来&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文的源码分析基于Retrofit 2.0，和Retrofit 1.0有较大的不同&lt;/strong&gt;， 本文主要分为几部分：0、Retrofi 是什么，1、Retrofi怎么用，2、Retrofit的原理是什么，3、我的心得与看法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面说的Retrofit全部指Retrofit 2&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>为什么技术团队应该写博客？</title>
    <link href="http://bxbxbai.gitcafe.io/2015/09/29/why-a-team-should-write-a-blog/"/>
    <id>http://bxbxbai.gitcafe.io/2015/09/29/why-a-team-should-write-a-blog/</id>
    <published>2015-09-29T11:16:25.000Z</published>
    <updated>2016-03-12T06:59:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>我本人平时很喜欢看一些博客，包括技术的和非技术的，慢慢也积累了很多博客列表，包括个人的和团队的</p>
<p>很久以前我看到过大神刘未鹏写的文章：<a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" target="_blank" rel="external">为什么你应该（从现在开始就）写博客</a>，文中很多道理直到我也开始写博客的时候才慢慢领悟到。比如，我可能对一个技术或概念很熟悉了，但是当我要说出来或者写下来给别人看的时候，就会发现有些技术的细节没考虑清楚。因此，当你写一篇博客的时候，其实你就是在逼迫你自己去把每一个细节都弄清楚</p>
<a id="more"></a>
<h2 id="国内外的技术博客"><a href="#国内外的技术博客" class="headerlink" title="国内外的技术博客"></a>国内外的技术博客</h2><p>我也列举一些我收藏的，也经常会看的博客（排序不分先后）。</p>
<h3 id="Facebook"><a href="#Facebook" class="headerlink" title="Facebook"></a>Facebook</h3><p>网址：<a href="https://code.facebook.com" target="_blank" rel="external">https://code.facebook.com</a></p>
<p>博客上会介绍一些Facebook在Android、iOS、前端、后端以及硬件技术遇到的问题，也包括一些他们团队研究的新技术，比如<code>fresco</code>等等。我最感兴趣的是他们在技术上遇到的一些问题，然后他们是怎么解决的</p>
<h3 id="Square"><a href="#Square" class="headerlink" title="Square"></a>Square</h3><p>网址：<a href="http://square.github.io/" target="_blank" rel="external">http://square.github.io/</a></p>
<p>Square应该是业界开源项目最多的公司之一了，它的github主页上列举了好多开源项目，一个做Android的如果没用过Square的开源库的话，要么你非常非常牛逼，要么你真的不关心开源项目</p>
<h3 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h3><p>网址：<a href="http://tech.meituan.com/" target="_blank" rel="external">http://tech.meituan.com/</a></p>
<p>从它的博客可以看到美团大概是从2013开慢慢写的，大概是因为2013后美团不断扩大，也慢慢积累了很多技术（踩了很多坑），博客上会写各种技术的：Android、iOS、前端、运维、机器学习等等~</p>
<h3 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h3><p>网址：<a href="http://jaq.alibaba.com/" target="_blank" rel="external">阿里聚安全</a></p>
<p>抱歉我没有找到阿里公开的技术博客站点，之前我在阿里的时候，我在内网看到，公司内部会有很多人分享自己遇到的问题以及解决方法，公开的博客，我还没有发现</p>
<p>网址：<a href="http://yq.aliyun.com/teams/13?spm=5176.blog2696.yqblogcon1.2.AiZpYX" target="_blank" rel="external">手机淘宝技术团队</a></p>
<h3 id="微信移动团队"><a href="#微信移动团队" class="headerlink" title="微信移动团队"></a>微信移动团队</h3><p>这个应该没有博客，只有微信公众号：WeMobileDev<br>貌似也是最近才开的，博客文章的质量非常高，每一篇基本都是微信移动团队经验的总结，详细介绍了他们遇到的困难以及如何解决的。比如：提升Android客户端会话速度提升70%背后的故事、Android微信只能心跳方案、Android拆分与加载Dex的多种方案等等</p>
<p>每一篇都会具体到技术的细节，真正的解决每一个问题，非常赞这样的技术团队</p>
<h3 id="腾讯的bugly"><a href="#腾讯的bugly" class="headerlink" title="腾讯的bugly"></a>腾讯的bugly</h3><p>网址：<a href="http://bugly.qq.com/blog/" target="_blank" rel="external">http://bugly.qq.com/blog/</a><br>Bugly的博客会介绍一些Android和iOS开发过程中帮助我们性能分析的方法，比如如何衡量一个App的卡顿情况呢？Bugly的博客告诉你，使用<code>Choreographer.FrameCallback</code>这个工具。还有很多其他的性能分析的技巧</p>
<h2 id="为什么要开始写博客"><a href="#为什么要开始写博客" class="headerlink" title="为什么要开始写博客"></a>为什么要开始写博客</h2><p>刘未鹏的文章其实已经回答了这个问题，那是一篇非常好的文章。</p>
<p>不过我还是想说说我自己的想法：</p>
<p>首先，可以有技术沉淀。一个公司或者技术团队（简称团队）肯定在业务发展的过程中会遇到并且解决很多的技术难题，如果把这些经验记下来，并且对外公布（如果没有涉及公司机密的话），这样会让很多人受益。</p>
<p>其次，可以促进技术交流，然后吸引公司外部喜欢技术的人加入公司。我始终相信，一个热爱技术的人，肯定是喜欢和技术牛X的人待一起工作的。而且，我也相信，当一个人真正喜欢技术以后，在走路或者吃饭的时候谈技术都是很平常的事情。比如，像微信移动团队那样，输出高质量的技术文章，是肯定可以吸引到热爱技术的人，这样的话团队只会越来越强</p>
<p>最后，<a href="http://mindhacks.cn/2009/02/09/writing-is-better-thinking/" target="_blank" rel="external">写作是为了更好的思考</a>。这是刘未鹏说的，书写可以让你整理你思考的内容，写下来和我自己想想还是有很大区别的。写作还可以激励团队持续的学习，技术在不断发展，技术难题也在不断增加，让团队持续学习才是根本呀</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>从上面的博客中可以看到，优秀的技术公司是总结并且分享自己经验，然而卓越而伟大的技术公司，比如Facebook和Square等，是在创造新的技术，比如<code>fresco</code>、<code>stetho</code>、<code>okhttp</code>和<code>retrofit</code>等等</p>
<p>我是相信一些技术牛逼或者正在成为技术牛逼的人都是发自内心的喜欢技术，可能开始ta的技术并不是很厉害，但是ta会花空余的时间去了解并且研究一些新的技术。然后，自己不断总结和反思，这样的人对一个团队和公司都是一种财富</p>
<p>我自己有体会，之前遇到的难题，我解决了，如果不总结一下，有些会随着时间慢慢忘记掉，所以我自己写博客很大一部分原因也是为了自己以后来温故自己的经验</p>
<p>如果你经常看不错的技术博客，欢迎和我分享~</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我本人平时很喜欢看一些博客，包括技术的和非技术的，慢慢也积累了很多博客列表，包括个人的和团队的&lt;/p&gt;
&lt;p&gt;很久以前我看到过大神刘未鹏写的文章：&lt;a href=&quot;http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;为什么你应该（从现在开始就）写博客&lt;/a&gt;，文中很多道理直到我也开始写博客的时候才慢慢领悟到。比如，我可能对一个技术或概念很熟悉了，但是当我要说出来或者写下来给别人看的时候，就会发现有些技术的细节没考虑清楚。因此，当你写一篇博客的时候，其实你就是在逼迫你自己去把每一个细节都弄清楚&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂感" scheme="http://bxbxbai.gitcafe.io/tags/%E6%9D%82%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>谈谈App混合开发</title>
    <link href="http://bxbxbai.gitcafe.io/2015/08/16/talk-about-bybird-app/"/>
    <id>http://bxbxbai.gitcafe.io/2015/08/16/talk-about-bybird-app/</id>
    <published>2015-08-16T08:07:11.000Z</published>
    <updated>2015-12-23T07:25:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>混合开发的App（Hybrid App）就是在一个App中内嵌一个轻量级的浏览器，一部分原生的功能改为Html 5来开发，这部分功能不仅能够在不升级App的情况下动态更新，而且可以在Android或iOS的App上同时运行，让用户的体验更好又可以节省开发的资源。</p>
<p>下面来谈谈Hybrid App开发中的技术问题。iOS方面的我不太了解，我就主要谈谈Android开发中的，其中可能会有很多说错的，请大家轻喷</p>
<a id="more"></a>
<h1 id="Hybrid开发中关键问题是什么"><a href="#Hybrid开发中关键问题是什么" class="headerlink" title="Hybrid开发中关键问题是什么"></a>Hybrid开发中关键问题是什么</h1><p>想要在一个App中显示一个Html 5网页的功能，其实很简单，只要一个WebView就可以了。你可以点击链接来跳转网页。像这样的功能就能叫做Hybrid 开发了嘛？显然不是的。</p>
<p><strong>我觉得一个Hybrid开发的App中必须要要有的功能就是Html 5页面和Native App怎么进行交互</strong>。比如，我点了一个Html 5页面上的一个按钮或链接，我能不能够跳转到Native App的某个页面；比如我点了Html 5页面上的分享按钮，我能不能调用Native App的分享功能；比如Html加载的时候能不能获取Native App的用户信息等等。</p>
<p>看下图，在网易云音乐中进入这个Html 5页面时，你点击<strong>作者：空虚小编</strong>你会进入他的主页，这个主页是Native页面，而你点击上面那个播放按钮时，云音乐会启动Native的播放界面播放音乐，你点击评论时，你会进入Native的评论页</p>
<p><img src="http://i1.tietuku.com/5575cfa4108a1f0e.png" alt="此处输入图片的描述"></p>
<h1 id="Html-5和Native的交互"><a href="#Html-5和Native的交互" class="headerlink" title="Html 5和Native的交互"></a>Html 5和Native的交互</h1><p><code>WebView</code>本来就支持js和Java相互调用，你只需要开启<code>WebView</code>的JavaScript脚本执行，然后通过代码<code>mWebView.addJavascriptInterface(new JsBridge(), &quot;bxbxbai&quot;);</code>向Html 5页面时注入一个Java对象，然后就可以在Html 5页面中调用Native的功能了</p>
<h2 id="微信怎么做的"><a href="#微信怎么做的" class="headerlink" title="微信怎么做的"></a>微信怎么做的</h2><p>微信应该是Hybrid 开发做的最好的App之一，它是怎么做交互的呢？</p>
<p>答案就是<code>微信JS-SDK</code>，去微信开发者文档中可以看到，微信JS-SDK封装了各种微信的功能，比如分享到朋友圈，图像接口，音频接口，支付接口地理位置接口等等。开发者只需要调用微信JS-SDK中的函数，然后统一由JS-SDK来调用微信中的功能，这样好处就是我写了一个Html 5的应用或网页，在Android和iOS的微信中都可以正常运行了</p>
<p>下面会详细讲到</p>
<h2 id="网易云音乐怎么做的"><a href="#网易云音乐怎么做的" class="headerlink" title="网易云音乐怎么做的"></a>网易云音乐怎么做的</h2><p>那么网易云音乐是怎么做的呢？我用黑科技知道了上图云音乐的界面Activity是<code>CommonSubjectActivity</code>（名字好奇怪，如果要我从代码里找，我肯定找不到，因为还有一个类叫做<code>EmbedBrowserActivity</code>），我就在反编译后的云音乐代码中找相应的功能实现代码，实在没找到。不过我拿到了那个Html 5页面的地址：<a href="http://music.163.com/m/topic/194001" target="_blank" rel="external">http://music.163.com/m/topic/194001</a></p>
<p>用Chrome打开后发现和App中显示的不一样，然后我用Charles截了进入那个Html 5的请求，发现云音乐加载的地址是<a href="http://music.163.com/m/topic/194001?type=android" target="_blank" rel="external">http://music.163.com/m/topic/194001?type=android</a> ，就是加了手机系统类型</p>
<p>然后在我自己的App中加载这个Html 5页面就可以看到下图，<strong>@小比比说</strong>这样的文字是可以点击跳转到个人，点击播放按钮是可以播放音乐的</p>
<p><img src="http://i3.tietuku.com/b00f74ef47f9ee0d.png" alt="此处输入图片的描述"></p>
<p>从Html源代码中可以看到如下信息：</p>
<p><img src="http://i3.tietuku.com/0197b3a47d0c2f1a.png" alt="此处输入图片的描述"></p>
<p>也就是说，当我点击一个用户名的时候就请求跳转到<code>orpheus://user/30868859</code>，因为WebView可以拦截跳转的url，所以App在拦截每一个url，如果host是<code>orpheus</code>的话就启动用户首页</p>
<p>反编译代码后，在云音乐的代码中找到了<code>this.mWebView.setWebViewClient(new cf(this));</code>这么一句代码，进入<code>cf</code>类，发现下面代码：</p>
<pre><code>public boolean shouldOverrideUrlLoading(WebView webView, String url) {
    if (url.startsWith(&quot;orpheus://&quot;)) {
        RedirectActivity.a(this.activity, url);
        return true;
    }
    if ((url.toLowerCase().startsWith(&quot;http://&quot;)) || (url.toLowerCase().startsWith(&quot;https://&quot;))) {
        return false;
    }
    try {
        this.activity.startActivity(new Intent(&quot;android.intent.action.VIEW&quot;, Uri.parse(url)));
        return true;
    } catch (ActivityNotFoundException localActivityNotFoundException) {
        localActivityNotFoundException.printStackTrace();
    }
    return true;
}
</code></pre><p>果然如此，再进入<code>RedirectActivity</code>，这是一个没有任何界面的Activity，专门用于处理页面跳转信息，它会调用一个方法<code>NeteaseMusicUtils.redirect(this, getIntent().getData().toString(), false)</code>来处理url，<code>redirect</code>方法的名字是我自己写的，部分代码如下：</p>
<p><img src="http://i3.tietuku.com/99edcdc0195316cf.png" alt="此处输入图片的描述"></p>
<p>可以看到<code>orpheus://user/30868859</code>中的用户id被传入了<code>ProfileAcvitiy</code>，因此启动了用户首页显示了用户信息</p>
<p>然后我自己写了代码拦截Html 5的跳转，打印出的Log如下：</p>
<p><img src="http://i3.tietuku.com/68f3abf5eb92745c.png" alt="此处输入图片的描述"></p>
<p>可以看到Html 5页面可以跳转到各种页面，比如用户首页、播放音乐、MV界面、评论页、电台节目等等</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般来讲，也是我目前知道的两种主流的方式就是</p>
<ol>
<li>js调用Native中的代码</li>
<li>Schema：WebView拦截页面跳转</li>
</ol>
<p>第2种方式实现起来很简单，但是一个致命的问题就是这种交互方式是单向的，Html 5无法实现回调。像云音乐App中这种点击跳转到具体页面的功能，Schema的方式确实可以简单实现，而且也非常适合。如果需求变得复杂，假如Html 5需要获取Native App中的用户信息，那么最好使用js调用的方式。</p>
<h1 id="js和Native进行交互"><a href="#js和Native进行交互" class="headerlink" title="js和Native进行交互"></a>js和Native进行交互</h1><p>上面讲到WebViewbe本身就是支持js调用Native代码的，不过WebView的这个功能在Android 4.2（API 17）一下存在高危的漏洞。这个漏洞的原理就是Android系统通过<code>WebView.addJavascriptInterface(Object o, String interface)</code>方法注册可供js调用的Java对象，但是系统并没有对注册的Java对象方法调用做限制。导致攻击者可以利用反射调用未注册的其他任何Java对象，攻击者可以根据客户端的能力做任何事情。<a href="http://jaq.alibaba.com/blog.htm?id=48" target="_blank" rel="external">这篇文章</a>详细的介绍了这个漏洞</p>
<p>出于安全考虑，Android 4.2以后的系统规定允许被js调用的Java方法必须以<code>@JavascriptInterface</code>进行注解</p>
<h2 id="Cordova的解决方案"><a href="#Cordova的解决方案" class="headerlink" title="Cordova的解决方案"></a>Cordova的解决方案</h2><p>Cordova是一个广泛使用的Hybrid开发框架，它提供了一套js和Native交互规范</p>
<p>在Cordova的<code>SystemWebViewEngine</code>类中可以看到</p>
<pre><code>private static void exposeJsInterface(WebView webView, CordovaBridge bridge) {
    if ((Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN_MR1)) {
        Log.i(TAG, &quot;Disabled addJavascriptInterface() bridge since Android version is old.&quot;);
        // Bug being that Java Strings do not get converted to JS strings automatically.
        // This isn&apos;t hard to work-around on the JS side, but it&apos;s easier to just
        // use the prompt bridge instead.
        return;
    }
    webView.addJavascriptInterface(new SystemExposedJsApi(bridge), &quot;_cordovaNative&quot;);
}
</code></pre><p>因此当Android系统高于4.2时，Cordova还是使用<code>addJavascriptInterface</code>这种方式，因为这个方法在高版本上安全而且简单，低于4.2的时候，用什么方法呢？</p>
<p><strong>答案是<code>WebChromeClient.onJsPrompt</code>方法</strong></p>
<p>WebView可以设置一个<code>WebChromeClient</code>对象，它可以处理js的3个方法</p>
<ul>
<li><code>onJsAlert</code></li>
<li><code>onJsConfirm</code></li>
<li><code>onJsPrompt</code></li>
</ul>
<p>这3个方法分别对应js的<code>alert</code>、<code>confirm</code>、<code>prompt</code>方法，因为只有<code>prompt</code>接收返回值，所以js调用一个Native方法后可以等待Native返回一个参数。下面是<code>cordova.js</code>中的一段代码：</p>
<pre><code>/**
* Implements the API of ExposedJsApi.java, but uses prompt() to communicate.
* This is used pre-JellyBean, where addJavascriptInterface() is disabled.
*/
module.exports = {
    exec: function(bridgeSecret, service, action, callbackId, argsJson) {
        return prompt(argsJson, &apos;gap:&apos;+JSON.stringify([bridgeSecret, service, action, callbackId]));
    },
    setNativeToJsBridgeMode: function(bridgeSecret, value) {
        prompt(value, &apos;gap_bridge_mode:&apos; + bridgeSecret);
    },
    retrieveJsMessages: function(bridgeSecret, fromOnlineEvent) {
        return prompt(+fromOnlineEvent, &apos;gap_poll:&apos; + bridgeSecret);
    }
};
</code></pre><p>然后只要在<code>onJsPrompt</code>方法中使用<code>CordovaBridge</code>来处理js的prompt调用</p>
<pre><code>/**
 * Tell the client to display a prompt dialog to the user. If the client returns true, WebView will assume that the client will handle the prompt dialog and call the appropriate JsPromptResult method.
 * &lt;p/&gt;
 * Since we are hacking prompts for our own purposes, we should not be using them for this purpose, perhaps we should hack console.log to do this instead!
 */
@Override
public boolean onJsPrompt(WebView view, String origin, String message, String defaultValue, final JsPromptResult result) {
    // Unlike the @JavascriptInterface bridge, this method is always called on the UI thread.
    String handledRet = parentEngine.bridge.promptOnJsPrompt(origin, message, defaultValue);
    if (handledRet != null) {
        result.confirm(handledRet);
    } else {
        dialogsHelper.showPrompt(message, defaultValue, new CordovaDialogsHelper.Result() {
            @Override
            public void gotResult(boolean success, String value) {
                if (success) {
                    result.confirm(value);
                } else {
                    result.cancel();
                }
            }
        });
    }
    return true;
}
</code></pre><h2 id="一种开源的解决方案"><a href="#一种开源的解决方案" class="headerlink" title="一种开源的解决方案"></a>一种开源的解决方案</h2><p>Cordova是Apache的一个开源解决方案，不过它需要xml配置<code>CordovaPlugin</code>信息，使用会比较麻烦，而且这个框架很重，具体请自行搜索Cordova使用教程</p>
<p>下面这个开源项目是我个人觉得比较合理的解决方案，也比较轻量级，下图就是一个Demo</p>
<p><a href="https://github.com/pedant/safe-java-js-webview-bridge" target="_blank" rel="external">https://github.com/pedant/safe-java-js-webview-bridge</a></p>
<p><img src="http://i3.tietuku.com/14cc4af678f56eaf.png" alt="此处输入图片的描述"></p>
<p>这个项目的原理就是使用<code>WebChromeClient.onJsPrompt</code>方法来进行交互，本质上都是js调用<code>prompt</code>函数，传输一些参数，<code>onJsPrompt</code>方法拦截到prompt动作，然后解析数据，最后调用相应的Native方法</p>
<p><strong>HostJsScope</strong>类中定义了所有可以被js调用的方法，这些方法都必须是静态方法，并且所有的方法第一个参数必须是WebView</p>
<pre><code>/**
* HostJsScope中需要被JS调用的函数，必须定义成public static，且必须包含WebView这个参数
*/
public class HostJsScope {
    /**
    * 短暂气泡提醒
    * @param webView 浏览器
    * @param message 提示信息
    * */
    public static void toast(WebView webView, String message) {
        Toast.makeText(webView.getContext(), message, Toast.LENGTH_SHORT).show();
    }

    /**
    * 系统弹出提示框
    * @param webView 浏览器
    * @param message 提示信息
    * */
    public static void alert(WebView webView, String message) {
        // 构建一个Builder来显示网页中的alert对话框
        AlertDialog.Builder builder = new AlertDialog.Builder(webView.getContext());
        builder.setPositiveButton(android.R.string.ok, new AlertDialog.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                dialog.dismiss();
            }
        });
        builder.setTitle(&quot;Hello world&quot;)
            .setMessage(message)
            .setCancelable(false)
            .create()
            .show();
    }

    // 其他代码

}
</code></pre><p>上面代码列举了最基本的点击Html 5按钮弹出对话框的功能</p>
<p>这个库中一个最关键的叫做<code>JsCallJava</code>，这个实现的就是js来调用Java方法的功能，这个类只用于<code>InjectedWebChromeClient</code>类</p>
<pre><code>public class InjectedChromeClient extends WebChromeClient {

    private JsCallJava mJsCallJava;
    private boolean mIsInjectedJS;

    public InjectedChromeClient(String injectedName, Class injectedCls) {
        this(new JsCallJava(injectedName, injectedCls));
    }

    public InjectedChromeClient(JsCallJava jsCallJava) {
        mJsCallJava = jsCallJava;
    }

    // 处理Alert事件
    @Override
    public boolean onJsAlert(WebView view, String url, String message, final JsResult result) {
        result.confirm();
        return true;
    }

    @Override
    public void onProgressChanged(WebView view, int newProgress) {
        //为什么要在这里注入JS
        //1 OnPageStarted中注入有可能全局注入不成功，导致页面脚本上所有接口任何时候都不可用
        //2 OnPageFinished中注入，虽然最后都会全局注入成功，但是完成时间有可能太晚，当页面在初始化调用接口函数时会等待时间过长
        //3 在进度变化时注入，刚好可以在上面两个问题中得到一个折中处理
        //为什么是进度大于25%才进行注入，因为从测试看来只有进度大于这个数字页面才真正得到框架刷新加载，保证100%注入成功
        if (newProgress &lt;= 25) {
            mIsInjectedJS = false;
        } else if (!mIsInjectedJS) {
            view.loadUrl(mJsCallJava.getPreloadInterfaceJS());
            mIsInjectedJS = true;
            StopWatch.log(&quot; inject js interface completely on progress &quot; + newProgress);
        }
        super.onProgressChanged(view, newProgress);
    }

    @Override
    public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) {
        result.confirm(mJsCallJava.call(view, message));
        StopWatch.log(&quot;onJsPrompt: &quot; + view.toString() +&quot;, &quot; + url +&quot;, &quot; + message +&quot;, &quot; + defaultValue + &quot;, &quot; + result) ;
        return true;
    }
}   
</code></pre><p>这个<code>InjectedWebChromeClient</code>是设给WebView的，这里一个非常重要的细节需要注意一下，在<code>onProgressChange</code>方法中，向WebView注入了一段js代码，这段js代码如下：</p>
<pre><code>javascript: (function(b) {
    console.log(&quot;HostApp initialization begin&quot;);
    var a = {
        queue: [],
        callback: function() {
            var d = Array.prototype.slice.call(arguments, 0);
            var c = d.shift();
            var e = d.shift();
            this.queue[c].apply(this, d);
            if (!e) {
                delete this.queue[c]
            }
        }
    };
    a.alert = a.alert = a.alert = a.delayJsCallBack = a.getIMSI = a.getOsSdk = a.goBack = a.overloadMethod = a.overloadMethod 
        = a.passJson2Java = a.passLongType = a.retBackPassJson = a.retJavaObject = a.testLossTime = a.toast = a.toast = function() {
        var f = Array.prototype.slice.call(arguments, 0);
        if (f.length &lt; 1) {
            throw &quot;HostApp call error, message:miss method name&quot;
        }
        var e = [];
        for (var h = 1; h &lt; f.length; h++) {
            var c = f[h];
            var j = typeof c;
            e[e.length] = j;
            if (j == &quot;function&quot;) {
                var d = a.queue.length;
                a.queue[d] = c;
                f[h] = d
            }
        }
        var g = JSON.parse(prompt(JSON.stringify({
            method: f.shift(),
            types: e,
            args: f
        })));
        if (g.code != 200) {
            throw &quot;HostApp call error, code:&quot; + g.code + &quot;, message:&quot; + g.result
        }
        return g.result
    };
    //有时候，我们希望在该方法执行前插入一些其他的行为用来检查当前状态或是监测
    //代码行为，这就要用到拦截（Interception）或者叫注入（Injection）技术了
    /**
     * Object.getOwnPropertyName 返回一个数组，内容是指定对象的所有属性
     *
     * 其后遍历这个数组，分别做以下处理：
     * 1. 备份原始属性；
     * 2. 检查属性是否为 function（即方法）；
     * 3. 若是重新定义该方法，做你需要做的事情，之后 apply 原来的方法体。
     */
    Object.getOwnPropertyNames(a).forEach(function(d) {
        var c = a[d];
        if (typeof c === &quot;function&quot; &amp;&amp; d !== &quot;callback&quot;) {
            a[d] = function() {
                return c.apply(a, [d].concat(Array.prototype.slice.call(arguments, 0)))
            }
        }
    });
    b.HostApp = a;
    console.log(&quot;HostApp initialization end&quot;)
})(window);
</code></pre><p>那么这段js代码是如何生成的呢？答案就在<code>JsCallJava</code>类的构造函数方法中，这个构造方法做的事情就是解析<code>HostJsScope</code>类中的方法，把每一个方法的签名都保持到<code>private Map&lt;String, Method&gt; mMethodsMap</code>中，再看上面那段js代码中</p>
<blockquote>
<p>a.alert = a.alert = a.alert = a.delayJsCallBack = a.getIMSI = a.getOsSdk = a.goBack = a.overloadMethod = a.overloadMethod<br>            = a.passJson2Java = a.passLongType = a.retBackPassJson = a.retJavaObject = a.testLossTime = a.toast = a.toast = function()</p>
</blockquote>
<p>这些都是<code>HostJsScope</code>类中定义的方法名</p>
<p>那么这个库的整个执行流程是这样的：</p>
<ol>
<li><code>JsCallJava</code>类解析了<code>HostJsScope</code>类中所有的静态方法，将它们放到一个Map中，并且生成一段js代码</li>
<li>向WebView设置<code>InjectedChromeClient</code>，在<code>onProgressChanged</code>方法中将那段js代码注入到Html5页面中，这个过程通俗点讲就是，<strong>Native告诉Html 5页面，我开放了什么功能给你，你就来调用我</strong></li>
<li>这样js就可以调用Native提供的这些方法，那段js代码还会将js执行的方法转换成一段json字符串，通过js的prompt方法传到<code>onJsPrompt</code>方法中，<code>JsCallJava</code>调用<code>call(WebView view, String msg)</code>解析json字符串，包括要执行的<strong>方法名字</strong>，<strong>参数类型</strong>和<strong>方法参数</strong>，其中还会验证json中的方法参数类型和<code>HostJsScope</code>中同名方法参数类型是否一致等等。</li>
<li>最后，如果方法正确执行，<code>call</code>方法就返回一个json字符串code=200，否则就传code=500，这个信息会通过<code>prompt</code>方法的返回值传给js，这样Html 5 代码就能知道有没有正确执行了</li>
</ol>
<p>以上就是这个开源库的整个原理，我个人觉得非常适合用于Hybrid开发，这个解决方案中js可以收到Native的返回值，而且没有使用<code>addJavascriptInterface</code>方法，在低版本手机上也不会有安全问题，这个方法比Cordova的实现和配置简单</p>
<p>那么当我点击Html 5页面上的一个按钮，比如弹出对话框，这个过程的整体流程是怎么样的呢</p>
<h2 id="微信的解决方案？"><a href="#微信的解决方案？" class="headerlink" title="微信的解决方案？"></a>微信的解决方案？</h2><p>什么？你问我微信是怎么解决的？我也反编译了微信的代码，想研究一下他们是解决的，其实我非常好奇微信的这种js 调用Native，并且又返回的调用方法</p>
<p>首先，我去微信的js sdk官网看了一下js sdk提供的功能，提供了各种强大的功能，各位可以自己去看一下。那么问题来了，微信是怎么做到js 调用Native并且能够成功返回的呢？</p>
<p>带着疑问我反编译了微信Android客户端，在assers/jsapi中看到了<code>wxjs.js</code>文件，我想这个就是微信js sdk的源码了吧。。。</p>
<p>我首先说一下，我不太懂js的代码， 我只能连蒙带猜的看微信的js代码，<code>如果有js大神对这方面也感兴趣，希望可以一起(jian)探(fei)讨(zao)</code></p>
<p>在<code>wxjs.js</code>中看到了一下代码，我猜微信就是用这个<code>__WeixinJSBridge</code>当时js和Native进行通信的数据结构吧？</p>
<pre><code>var __WeixinJSBridge = {
    // public
    invoke:_call,
    call:_call,
    on:_onfor3rd,
    env:_env,
    log:_log,
    // private
    // _test_start:_test_start,
    _fetchQueue: _fetchQueue,
    _handleMessageFromWeixin: _handleMessageFromWeixin,
    _hasInit: false,
    _continueSetResult: _continueSetResult
};
</code></pre><p>然后我又看到了下面的代码，我想应该是提供分享内容到朋友圈功能的吧</p>
<pre><code>// share timeline
_on(&apos;menu:share:timeline&apos;,function(argv){
  _log(&apos;share timeline&apos;);

  var data;
  if (typeof argv.title === &apos;string&apos;) {
    data = argv;
    _call(&apos;shareTimeline&apos;,data);
  }else{
    data = {
        // &quot;img_url&quot;: &quot;&quot;,
        // &quot;img_width&quot;: &quot;&quot;,
        // &quot;img_height&quot;: &quot;&quot;,
        &quot;link&quot;: document.documentURI || _session_data.init_url,
        &quot;desc&quot;: document.documentURI || _session_data.init_url,
        &quot;title&quot;: document.title
    };

    var shareFunc = function(_img){          
      if (_img) {
          data[&apos;img_url&apos;] = _img.src;
          data[&apos;img_width&apos;] = _img.width;
          data[&apos;img_height&apos;] = _img.height;                        
      }

      _call(&apos;shareTimeline&apos;,data);
    };

    getSharePreviewImage(shareFunc);
  }
});
</code></pre><p>请注意最后这句：<code>_call(&#39;shareTimeline&#39;,data);</code>，在看看<code>__WeixinJSBridge</code>中的<code>call</code>属性，接着我找到了<code>_call</code>方法。</p>
<pre><code>function _call(func,params,callback) {
    var curFuncIdentifier = __WeixinJSBridge.call;
    if (curFuncIdentifier !== _callIdentifier) {
        return;
    }
    if (!func || typeof func !== &apos;string&apos;) {
        return;
    };
    if (typeof params !== &apos;object&apos;) {
        params = {};
    };

    var callbackID = (_callback_count++).toString();

    if (typeof callback === &apos;function&apos;) {
      _callback_map[callbackID] = callback;
    };

    var msgObj = {&apos;func&apos;:func,&apos;params&apos;:params};
    msgObj[_MESSAGE_TYPE] = &apos;call&apos;;        
    msgObj[_CALLBACK_ID] = callbackID;

    _sendMessage(JSON.stringify(msgObj));
}
</code></pre><p>大致意思应该就是：就是将这个东西<code>_call(&#39;shareTimeline&#39;,data);</code>转换成一个json字符串吧，从这里看到微信的做法和上面那个开源库非常类似，简单并且安全。<code>_call</code>方法最后调用<code>_sendMessage</code>方法发送消息</p>
<pre><code>//将消息添加到发送队列，iframe的准备队列为weixin://dispatch_message/
function _sendMessage(message) {
    _sendMessageQueue.push(message);
    _readyMessageIframe.src = _CUSTOM_PROTOCOL_SCHEME + &apos;://&apos; + _QUEUE_HAS_MESSAGE;

    // var ifm = _WXJS(&apos;iframe#__WeixinJSBridgeIframe&apos;)[0];
    // if (!ifm) {
    //   ifm = _createQueueReadyIframe(document);
    // }
    // ifm.src = _CUSTOM_PROTOCOL_SCHEME + &apos;://&apos; + _QUEUE_HAS_MESSAGE;
};
</code></pre><p>从上面代码可以看到微信的js sdk也是将js的方法调用换成一个类似<code>weixin://dispatch_message/</code>这样的url，上面说的json封装的数据。那么我猜测微信的做法是类似网易云音乐的拦截url吗？如果真的是这样的话，就非常不安全了，随便一个Html 5页面可以伪造一个类似：<code>weixin://dispatch_message/</code>这样的url来调用微信的功能了，不过好在微信对每个js调用都必须带上appid。</p>
<p>在反编译后的微信代码，我看到了下面代码：</p>
<p><img src="http://i1.tietuku.com/003b8cf9f3012d19.png" alt="image"></p>
<p>我想这写就是微信想Html 5开放的接口吧？不过对比了一下微信js sdk的官网，我看到好多App提供的功能在js sdk中并没有找到，这样也没有太大关系，以为微信只要升级js sdk就可以使用其他功能了，因为Native已经开放了嘛~</p>
<p>从上面<code>__WeixinJSBridge</code>可以看到有一个熟悉<code>_handleMessageFromWeixin</code>，这个就是js来处理Native的回调接口，我用这个字符串在微信代码中搜索，结果如下：</p>
<p><img src="http://i3.tietuku.com/e0b5b487f20e50ac.png" alt="image"></p>
<p>因此，我大致猜测，微信中的js调Native功能是用拦截url的方式，而Native回调的话是使用<code>evaluateJavascript</code>方法</p>
<p>我也在js sdk中找到了相应的函数：</p>
<pre><code>function _handleMessageFromWeixin(message) {
    var curFuncIdentifier = __WeixinJSBridge._handleMessageFromWeixin;
    if (curFuncIdentifier !== _handleMessageIdentifier) {
        return &apos;{}&apos;;
    }

    var ret;
    var msgWrap
    if (_isUseMd5 === &apos;yes&apos;) {
      var realMessage = message[_JSON_MESSAGE];
      var shaStr = message[_SHA_KEY];
      var arr = new Array;
      arr[0] = JSON.stringify(realMessage);
      arr[1] = _xxyy;
      var str = arr.join(&quot;&quot;);
      var msgSha = &apos;&apos;;
        var shaObj = CryptoJS.SHA1(str);
        msgSha = shaObj.toString();
        if (msgSha !== shaStr) {
            _log(&apos;_handleMessageFromWeixin , shaStr : &apos; + shaStr + &apos; , str : &apos; + str + &apos; , msgSha : &apos; + msgSha);
            return &apos;{}&apos;;

        }
        msgWrap = realMessage;
    }
    //省略很多代码
</code></pre><p>微信的做法应该说非常基础，使用了原生的功能，但是安全，由于微信客户端对每一个js调用都有验证（appid），因此这也增加了一定的安全性</p>
<p>以上说的都是建立在我的分析正确的情况下。</p>
<h1 id="一些个人的想法"><a href="#一些个人的想法" class="headerlink" title="一些个人的想法"></a>一些个人的想法</h1><p>现在各种新的技术也在想办法解决Native开发的效率问题，想用技术来解决一套代码运行在Android和iOS客户端，我相信随着技术的发展这些问题都会解决。我也好期待Facebook即将推出的<a href="http://www.reactnativeandroid.com/" target="_blank" rel="external">React Native Android</a></p>
<h2 id="Hybrid开发适用于哪些功能"><a href="#Hybrid开发适用于哪些功能" class="headerlink" title="Hybrid开发适用于哪些功能"></a>Hybrid开发适用于哪些功能</h2><p>本文讲的Hybrid开发就是Native客户端中嵌入了Html App的功能，这方面微信应该是做的最好的，由于Html 5的效率以及耗电问题，我个人觉得用户是不能满足Web App的体验的，Hybrid App也只适用于某些场景。一些基础的功能，比如调用手机的摄像头，获取地理位置，登录注册功能等等，做成Native的功能，让Html 5来调用更好，这样的体验也更好。</p>
<p>如果你把一个登录和注册功能也做成Html 5，在弱网络环境下，这个体验应该会非常的差，或许你等半天还没加载出页面。你可能会说，我可以预先加载Html 5的代码，打开App时直接加载，那么我说你在给自己找麻烦，如果要这样的话，Native开发或许更快一点。</p>
<p>那么什么情况适合Html 5开发呢？像一些活动页面，比如秒杀、团购等适合做Html 5，因为这些页面可能涉及的非常炫而且复杂，Html 5开发或许会简单点，关键是这些页面时效性短，更新更快，因为一个活动说不定就一周时间，下周换活动，如果这样的话，你还做Native是肯定不行的</p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>有那么一句<a href="http://mindhacks.cn/2009/01/16/hammers-and-nails/" target="_blank" rel="external">古老的箴言</a>：</p>
<blockquote>
<p>如果你手里有一把锤子，所有东西看上去都想钉子</p>
</blockquote>
<p>千万不要以为Hybrid开发能够夸平台运行，就使用Hybrid开发任何功能。其实Facebook早期也是这么想的，后来就是因为WebView渲染效率底下，把整个应用改为Native开发，请看<a href="https://www.facebook.com/notes/facebook-engineering/under-the-hood-rebuilding-facebook-for-android/10151189598933920" target="_blank" rel="external">这里</a></p>
<p>引用Facebook的一段话：</p>
<blockquote>
<p>Today, we’re releasing a new version of Facebook for Android that’s been rebuilt in native code to improve speed and performance. To support the unique complexity of Facebook stories across devices, we’re moving from a hybrid native/webview to pure native code, allowing us to optimize the Facebook experience for faster loading, new user interfaces, disk cache, and so on.</p>
</blockquote>
<p>本文主要还是从技术上谈谈Hybrid开发中js和Native交互的技术实现原理。抛砖引玉，写的估计也有很多错的，希望技术大牛指出。</p>
<p>最后，我觉得那个开源的库是一个非常不错的解决方案，解决办法巧妙、简单而且安全。当时我debug了半天弄明白其中的原理后，我一拍大腿，这办法真好啊！！网易云音乐的解决办法适用于它的场景，不需要回调，Native只需要处理相应的信息，然后来实现页面跳转、播放音乐、播放MV等功能，这个方法也简单好用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;混合开发的App（Hybrid App）就是在一个App中内嵌一个轻量级的浏览器，一部分原生的功能改为Html 5来开发，这部分功能不仅能够在不升级App的情况下动态更新，而且可以在Android或iOS的App上同时运行，让用户的体验更好又可以节省开发的资源。&lt;/p&gt;
&lt;p&gt;下面来谈谈Hybrid App开发中的技术问题。iOS方面的我不太了解，我就主要谈谈Android开发中的，其中可能会有很多说错的，请大家轻喷&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>关于Android开发中Java对象序列化的一次测试</title>
    <link href="http://bxbxbai.gitcafe.io/2015/05/05/a-serializable-test/"/>
    <id>http://bxbxbai.gitcafe.io/2015/05/05/a-serializable-test/</id>
    <published>2015-05-05T11:29:24.000Z</published>
    <updated>2015-09-12T07:01:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android开发过程中会遇到很多情况，需要将一个Java序列化，比如序列化一个对象来保存当前一些信息，等下次App启动后再还原。</p>
<p>对象序列化可以有好多种方法，一般最简单的就是实现<code>Serializable</code>接口，通过<code>ObjectOutputStream</code>写到SD卡中；还有可以将Java对象序列化到数据库中；还可以将Java对象转成一个字符串，把这个字符串写到SD卡中，反序列化时读取这个字符串，并且转成一个Java对象。</p>
<p>如果只保存一个Java对象，你应该不会把它写到数据库中的，一般会使用另外两种方法，但是那种方法好呢？</p>
<a id="more"></a>
<h2 id="方法0：实现Serializable接口"><a href="#方法0：实现Serializable接口" class="headerlink" title="方法0：实现Serializable接口"></a>方法0：实现Serializable接口</h2><p>写上两段代码</p>
<pre><code>//将Object写入SD卡
private void writeObject(Object result) {
    ObjectOutputStream oos = null;
    FileOutputStream fileOutputStream = null;
    try {
        File file = new File(Config.getCachePath() + &quot;bxbxbai&quot;);
        fileOutputStream = new FileOutputStream(file);
        oos = new ObjectOutputStream(fileOutputStream);
        oos.writeObject(result);
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            fileOutputStream.close();
            oos.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

//读取Object
private Object readObject() {
    Object object = null;
    File file = new File(Config.getCachePath() + &quot;bxbxbai&quot;);
    if (file.isFile()) {
        ObjectInputStream ois = null;
        FileInputStream fileInputStream = null;
        try {
            fileInputStream = new FileInputStream(file);
            ois = new ObjectInputStream(fileInputStream);
            object = ois.readObject();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                fileInputStream.close();
                ois.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return object;
    }
    return null;
}
</code></pre><p>##方法1：将对象转换成String序列化</p>
<pre><code>//先用Gson将对象转换成String，然后把String写入SD卡
private void writeObjectString(Object result) {
    String s = new Gson().toJson(result);
    FileOutputStream fileOutputStream = null;
    try {
        File file = new File(Config.getCachePath() + &quot;bxbxbai_string&quot;);
        fileOutputStream = new FileOutputStream(file);
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(fileOutputStream));
        writer.write(s);
        writer.flush();
        writer.close();
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            fileOutputStream.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

//先读取String，然后转成Java对象
private Object readObjectString() {
    File file = new File(Config.getCachePath() + &quot;bxbxbai_string&quot;);
    if (file.isFile()) {
        try {
            Scanner scanner = new Scanner(file);
            StringBuilder json = new StringBuilder();
            while (scanner.hasNext()) {
                json.append(scanner.nextLine());
            }
            scanner.close();
            return new Gson.fromJson(json.toString(), SerializeStringResult.class);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    return null;
}
</code></pre><p>##测试</p>
<p>基本的功能代码已经都贴了，下面是测试代码：</p>
<pre><code>private void test() {
    try {
        //省略创建object代码，result0 和result1 完全一样
        StopWatch.begin(&quot;writeObject&quot;);
        writeObject(result0);
        StopWatch.end(&quot;writeObject&quot;);

        StopWatch.begin(&quot;readObject&quot;);
        Object o1 = readObject();
        StopWatch.end(&quot;readObject&quot;);

        //写String
        StopWatch.begin(&quot;writeObjectString&quot;);
        writeObjectString(result1);
        StopWatch.end(&quot;writeObjectString&quot;);

        StopWatch.begin(&quot;readObjectString&quot;);
        Object o2 = readObjectString();
        StopWatch.end(&quot;readObjectString&quot;);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre><p>测试数据是地址：<a href="http://bxbxbai.gitcafe.io/img/data.txt">地址</a>，测试手机使用LG-D858</p>
<p>##测试结果(单位ms)</p>
<table>
<thead>
<tr>
<th>.</th>
<th style="text-align:center"><strong>writeObject</strong></th>
<th style="text-align:right"><strong>readObject</strong></th>
<th style="text-align:right">writeObjectString</th>
<th style="text-align:right"><strong>readObjectString</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td style="text-align:center">324</td>
<td style="text-align:right">111</td>
<td style="text-align:right">44</td>
<td style="text-align:right">66</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td style="text-align:center">285</td>
<td style="text-align:right">104</td>
<td style="text-align:right">29</td>
<td style="text-align:right">60</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td style="text-align:center">286</td>
<td style="text-align:right">95</td>
<td style="text-align:right">30</td>
<td style="text-align:right">61</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td style="text-align:center">271</td>
<td style="text-align:right">91</td>
<td style="text-align:right">30</td>
<td style="text-align:right">60</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td style="text-align:center">288</td>
<td style="text-align:right">94</td>
<td style="text-align:right">29</td>
<td style="text-align:right">58</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td style="text-align:center">260</td>
<td style="text-align:right">91</td>
<td style="text-align:right">28</td>
<td style="text-align:right">63</td>
</tr>
<tr>
<td><strong>6</strong></td>
<td style="text-align:center">273</td>
<td style="text-align:right">93</td>
<td style="text-align:right">27</td>
<td style="text-align:right">60</td>
</tr>
<tr>
<td><strong>7</strong></td>
<td style="text-align:center">267</td>
<td style="text-align:right">92</td>
<td style="text-align:right">27</td>
<td style="text-align:right">61</td>
</tr>
<tr>
<td><strong>8</strong></td>
<td style="text-align:center">265</td>
<td style="text-align:right">172</td>
<td style="text-align:right">27</td>
<td style="text-align:right">59</td>
</tr>
<tr>
<td><strong>9</strong></td>
<td style="text-align:center">299</td>
<td style="text-align:right">97</td>
<td style="text-align:right">29</td>
<td style="text-align:right">64</td>
</tr>
<tr>
<td><strong>Average</strong></td>
<td style="text-align:center"><strong>282</strong></td>
<td style="text-align:right"><strong>104</strong></td>
<td style="text-align:right"><strong>30</strong></td>
<td style="text-align:right"><strong>61</strong></td>
</tr>
</tbody>
</table>
<p>一共测试了10次，平均结果如下：</p>
<ul>
<li>Serializable写：282ms</li>
<li>Serializable读：104ms</li>
<li>转String写：30ms</li>
<li>转String读：61ms</li>
</ul>
<p>也就是说将Java对象转成String再进行序列化以及反序列化可以大大减少时间。</p>
<blockquote>
<p>Once upon a time, this used the standard Java Object{Input,Output}Stream, but the default implementation relies heavily on reflection (even for standard types) and generates a ton of garbage.</p>
</blockquote>
<p>上面这段话是我几个月前我看<a href="http://bxbxbai.gitcafe.io/2014/12/24/read-volley-source-code/">Volley源码</a>的时候看到的，在<code>DiskBasedCache</code>类中，大致的意思就是之前Volley也是用Java对象的序列化来缓存HTTP 头信息的，后来发现<code>Object{Input,Output}Stream</code>序列化严重依赖反射机制，<strong>会在序列化过程中产生大量的临时对象，从而更加频繁的触发GC</strong>，后来Google的工程师自己写了一个简单的序列化和反序列化方法</p>
<p>##总结</p>
<p>从测试结果中可以看到，将Java对象转换成String，然后在把String序列化可以节省大量的时间。不仅如此，<code>Object{Input,Output}Stream</code>序列化方法严重依赖Java反射机制，在序列化过程中会产生大量的临时对象，会更加频繁的触发GC操作</p>
<p>所以，我觉得还是把Java对象转成String再序列化吧，可以提升不少性能呢 ：）</p>
<h2 id="2015-05-07-更新"><a href="#2015-05-07-更新" class="headerlink" title="2015.05.07 更新"></a>2015.05.07 更新</h2><p>我这个是测试这两个序列化方法的性能。注意一下，Gson库将一个Java对象转成字符串也是使用Java反射的，如果某些场景需要更高的性能，那么需要自己写序列化方法。</p>
<p>比如，参考<code>Parcelable</code>接口，我们自己写代码，将对象转换成字符串（而不是依赖Gson库来转成字符串）序列化，以及相应的反序列化。或许你还想到了其他更好的方法，希望你能和我分享讨论~ ：）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android开发过程中会遇到很多情况，需要将一个Java序列化，比如序列化一个对象来保存当前一些信息，等下次App启动后再还原。&lt;/p&gt;
&lt;p&gt;对象序列化可以有好多种方法，一般最简单的就是实现&lt;code&gt;Serializable&lt;/code&gt;接口，通过&lt;code&gt;ObjectOutputStream&lt;/code&gt;写到SD卡中；还有可以将Java对象序列化到数据库中；还可以将Java对象转成一个字符串，把这个字符串写到SD卡中，反序列化时读取这个字符串，并且转成一个Java对象。&lt;/p&gt;
&lt;p&gt;如果只保存一个Java对象，你应该不会把它写到数据库中的，一般会使用另外两种方法，但是那种方法好呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
      <category term="技术" scheme="http://bxbxbai.gitcafe.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>可以滑动切歌的播放控制条（模仿QQ音乐）</title>
    <link href="http://bxbxbai.gitcafe.io/2015/04/07/swipe-playbar/"/>
    <id>http://bxbxbai.gitcafe.io/2015/04/07/swipe-playbar/</id>
    <published>2015-04-07T11:59:09.000Z</published>
    <updated>2016-03-12T06:58:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>看了QQ音乐Android版有这个功能，觉得挺好玩的，就模仿它做了一个demo，可以滑动切歌（转换的gif严重失真，只能截图了 -.-）</p>
<p>项目地址：<a href="https://github.com/bxbxbai/SwipePlaybarDemo" target="_blank" rel="external">https://github.com/bxbxbai/SwipePlaybarDemo</a></p>
<p>下载地址：<a href="http://vdisk.weibo.com/s/GGofvp4_QVU/1428410542" target="_blank" rel="external">http://vdisk.weibo.com/s/GGofvp4_QVU/1428410542</a></p>
<p>底部播放条的歌曲信息可以滑动切换，并且专辑图会转动</p>
<a id="more"></a>
<h2 id="看看截图"><a href="#看看截图" class="headerlink" title="看看截图"></a>看看截图</h2><p>这个是4个播放条的截图：<br><img src="http://i2.tietuku.com/de77e5c2f25e89f1.png" alt="playbar"> </p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这个功能就是使用<code>ViewPager</code>这个组件来实现，然后最主要的就是为这个<code>ViewPager</code>写一个<code>PagerAapter</code>。这个<code>PagerAdapter</code>写起来也容易，但是我在这个类里做了一些优化。</p>
<p>这个<code>PagerAdapter</code>的全部代码就在下面：</p>
<pre><code>/**
  * PlayBar ViewPager Adapter 
  * 
  * @author bxbxbai
*/
public class PlayCtrlBarPagerAdapter extends PagerAdapter {

  private static final int NUM_SONGS = 10;
  private static final int ANIMATOR_DURATION = 1000 * 10;

  private LayoutInflater mInflater;

  private Queue&lt;View&gt; mReusableViews;


  public PlayCtrlBarPagerAdapter(Context context) {
    mInflater = LayoutInflater.from(context);
    mReusableViews = new ArrayDeque&lt;&gt;(NUM_SONGS);
  }

  @Override
  public int getCount() {
    return NUM_SONGS;
  }

  @Override
  public boolean isViewFromObject(View view, Object object) {
    return view == object;
  }

  @Override
  public void destroyItem(ViewGroup container, int position, Object object) {
    if (object instanceof View) {
        container.removeView((View) object);
        mReusableViews.add((View) object);
    }
  }

  @Override
  public Object instantiateItem(ViewGroup container, int position) {
    View v = mReusableViews.poll();
    if (v == null) {
        v = mInflater.inflate(R.layout.layout_music, container, false);
        setAnimator(v);
    }
    bindData(v, position);
    container.addView(v);
    return v;
 }

  private void bindData(View v, int position) {
    TextView songName = ButterKnife.findById(v, R.id.tv_song_name);
    songName.setText(&quot;Try - &quot; + position);

    ImageView artistImage = ButterKnife.findById(v, R.id.iv_artist_cover);
    if (position % 2 == 1) {
        artistImage.setImageResource(R.drawable.adele);
    } else {
        artistImage.setImageResource(R.drawable.bxbxbai);
    }
 }

  @Override
  public float getPageWidth(int position) {
    return 1.0f;
  }

  public static void setAnimator(View view) {
    ObjectAnimator animator = ObjectAnimator.ofFloat(view.findViewById(R.id.iv_artist_cover), &quot;rotation&quot;, 0f, 360f);
    animator.setRepeatCount(Integer.MAX_VALUE);
    animator.setDuration(ANIMATOR_DURATION);
    animator.setInterpolator(new LinearInterpolator());

    view.setTag(R.id.tag_animator, animator);
  }
}
</code></pre><h2 id="优化PagerAdapter"><a href="#优化PagerAdapter" class="headerlink" title="优化PagerAdapter"></a>优化PagerAdapter</h2><p><code>PagerAdapter</code>和Android中<code>ListView</code>的<code>Adapter</code>类似，但是一个主要的不同就是<code>PagerAdapter</code>提供了一个回调方法来让我们处理销毁的Item。</p>
<p>一个<code>ViewPager</code>默认的<code>offScreenPageLimit</code>为1，也就是说当一个<code>ViewPager</code>当前显示页为<code>2</code>，那么<code>PagerAdapter</code>中还存在左右两个Pager，也就是<code>1</code>和<code>3</code>。此时，如果我们将<code>ViewPager</code>滑向<code>3</code>，那么<code>PagerAdapter</code>首先会通过<code>public void destroyItem(ViewGroup container, int position, Object object)</code>方法销毁第<code>1</code>个Item，然后通过<code>public Object instantiateItem(ViewGroup container, int position)</code>生成第<code>4</code>的Item，并且显示当前的Item（为<code>3</code>）。此时，<code>PagerAdapter</code>中存在的Item为<code>2</code>和<code>4</code></p>
<p>从这个思路出发，我也就可以在<code>destroyItem</code>方法中保存这个object，然后在<code>instantiateItem</code>中使用。</p>
<h3 id="看上面的代码"><a href="#看上面的代码" class="headerlink" title="看上面的代码"></a>看上面的代码</h3><p>我写了一个<code>Queue&lt;View&gt; mReusableViews;</code>在<code>destroyItem</code>中保存被销毁的Item，然后在<code>instantiateItem</code>方法中首先去<code>mReusableViews</code>中获取。</p>
<p>如果存在可以重用的Item，那么就不用inflate一个View了，直接绑定数据就可以。否则就创建一个新的View来使用</p>
<p>在实验过程中发现，如果<code>ViewPager</code>的<code>offScreenPageLimit</code>为1，那么只需要创建3个View，其他的View都可以重复使用，这样就可以提升性能了</p>
<p>##如何让ImageView转起来</p>
<p>在<code>View</code>绑定数据的时候通过一个工具方法，为每个<code>View</code>都设置一个<code>ObjectAnimator</code>属性动画。然后我为这个<code>ViewPager</code>专门写了一个<code>ViewPager.PageTransformer</code>类</p>
<p>其实代码也很简单，就是当某一个page完全显示的时候（position为0），开始动画，否则停止动画</p>
<p>如果你需要在<code>ViewPager</code>上添加一些其他特效，那么可以通过<code>addTransformer</code>方法添加PageTransformer</p>
<pre><code>/**
 * 播放条的PagerTransformer
 *
 * @author bxbxbai
 */
public class PlaybarPagerTransformer implements ViewPager.PageTransformer {

  private List&lt;ViewPager.PageTransformer&gt; mTransformers = new ArrayList&lt;&gt;();

  @Override
  public void transformPage(View page, float position) {
    for (ViewPager.PageTransformer transformer : mTransformers) {
        transformer.transformPage(page, position);
    }

    //处理图片旋转

    StopWatch.log(&quot;page: &quot; + page + &quot;, pos: &quot; + position);

    if (position == 0) {
        ObjectAnimator animator = (ObjectAnimator) page.getTag(R.id.tag_animator);
        if (animator != null) {
            animator.start();
        }
    } else if (position == -1 || position == -2 || position == 1) {
        ObjectAnimator animator = (ObjectAnimator) page.getTag(R.id.tag_animator);
        if (animator != null) {
            animator.end();
        }
    }
  }


  public void addTransformer(ViewPager.PageTransformer transformer) {
    if (transformer != null) {
        mTransformers.add(transformer);
    }
  }
}
</code></pre><h2 id="Dependency-依赖"><a href="#Dependency-依赖" class="headerlink" title="Dependency - 依赖"></a>Dependency - 依赖</h2><ul>
<li>Java Development Kit (JDK) 7 +</li>
<li>com.android.tools.build:gradle:1.0.0</li>
<li>Android SDK<ul>
<li>Android SDK Build-tools 21.1.2</li>
</ul>
</li>
</ul>
<h2 id="Build-构建"><a href="#Build-构建" class="headerlink" title="Build - 构建"></a>Build - 构建</h2><pre><code>git clone https://github.com/bxbxbai/SwipePlaybarDemo.git
</code></pre><p>用最新的IntelliJ IDE导入工程（Import Project），然后等待IDE下载gradle和依赖包即可</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看了QQ音乐Android版有这个功能，觉得挺好玩的，就模仿它做了一个demo，可以滑动切歌（转换的gif严重失真，只能截图了 -.-）&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/bxbxbai/SwipePlaybarDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/bxbxbai/SwipePlaybarDemo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;http://vdisk.weibo.com/s/GGofvp4_QVU/1428410542&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://vdisk.weibo.com/s/GGofvp4_QVU/1428410542&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;底部播放条的歌曲信息可以滑动切换，并且专辑图会转动&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>知乎专栏App</title>
    <link href="http://bxbxbai.gitcafe.io/2015/03/26/zhuanlan/"/>
    <id>http://bxbxbai.gitcafe.io/2015/03/26/zhuanlan/</id>
    <published>2015-03-26T11:55:31.000Z</published>
    <updated>2016-03-12T07:00:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直在利用空余时间开发一个完整的App，名字就叫“专栏”。开发这个App的目的主要是为了练练手，熟悉开发一个完整App的流程。就像造房子，亲手打地基，搬砖头，垒砖头，还自己装修（虽然装修的不好看）</p>
<p>项目地址：<a href="https://github.com/bxbxbai/ZhuanLan" target="_blank" rel="external">https://github.com/bxbxbai/ZhuanLan</a></p>
<a id="more"></a>
<h2 id="1-1版本"><a href="#1-1版本" class="headerlink" title="1.1版本"></a>1.1版本</h2><p>现在App在Android 4.4系统上支持沉浸式状态栏了，个人感觉更加好看了，增加了抽屉菜单功能（部分功能还未完成）。</p>
<p>最新添加了“最近一周文章”功能，这功能会显示所有内置专栏作者最近一周的文章列表，并且所有的文章会按时间排序。还添加了“查看原网页”功能</p>
<h2 id="看截图："><a href="#看截图：" class="headerlink" title="看截图："></a>看截图：</h2><p><img src="http://i2.tietuku.com/0753db9e1804f6b3.png" alt="闪屏"></p>
<p><img src="http://i2.tietuku.com/2970239f71296398.png" alt="专栏列表"></p>
<p><img src="http://i2.tietuku.com/6fa9fc0c9c2de428.png" alt="文章列表"></p>
<p><img src="http://i2.tietuku.com/ace4ca3200ad7a09.png" alt="文章内容"></p>
<p><img src="http://i2.tietuku.com/da044bdfabfe3e4f.png" alt="网页版"></p>
<h2 id="Dependency-依赖"><a href="#Dependency-依赖" class="headerlink" title="Dependency - 依赖"></a>Dependency - 依赖</h2><ul>
<li>Java Development Kit (JDK) 7 +</li>
<li>com.android.tools.build:gradle:1.0.0</li>
<li>Android SDK 21</li>
<li>Android SDK Build-tools 21.1.2</li>
</ul>
<h2 id="Build-构建"><a href="#Build-构建" class="headerlink" title="Build - 构建"></a>Build - 构建</h2><pre><code>git clone https://github.com/bxbxbai/ZhuanLan.git
</code></pre><p>用最新的IntelliJ IDE导入工程（Import Project），然后等待IDE下载gradle和依赖包即可。</p>
<h2 id="用到的开源库"><a href="#用到的开源库" class="headerlink" title="用到的开源库"></a>用到的开源库</h2><ul>
<li>Volley</li>
<li>Gson</li>
<li>Material-Menu</li>
<li>systembartint</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一直在利用空余时间开发一个完整的App，名字就叫“专栏”。开发这个App的目的主要是为了练练手，熟悉开发一个完整App的流程。就像造房子，亲手打地基，搬砖头，垒砖头，还自己装修（虽然装修的不好看）&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/bxbxbai/ZhuanLan&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/bxbxbai/ZhuanLan&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
      <category term="开源" scheme="http://bxbxbai.gitcafe.io/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>Android开发笔记0</title>
    <link href="http://bxbxbai.gitcafe.io/2015/02/08/android-develop-notes-0/"/>
    <id>http://bxbxbai.gitcafe.io/2015/02/08/android-develop-notes-0/</id>
    <published>2015-02-08T03:13:56.000Z</published>
    <updated>2016-03-12T06:57:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些好用的开发技巧</p>
<a id="more"></a>
<h1 id="0-自定义一个View"><a href="#0-自定义一个View" class="headerlink" title="0. 自定义一个View"></a>0. 自定义一个View</h1><p>现在的音乐播放器，比如天天动听或网易云音乐中都会将推荐页面中的内容进行分块，比如热门推荐、个性化推荐、最新音乐等等。每个区块前面都会有一个标题，如下图：</p>
<p><img src="http://i2.tietuku.com/4ee54aa7c8091807.png" alt="云音乐"></p>
<p><img src="http://i2.tietuku.com/c9eee15f9b35fb2c.png" alt="虾米"></p>
<p>可能很多人还在重用布局文件（layout文件）来做这些功能，但是如果你现在又需要在另一个（或多个）页面中使用这个标题，那么你就必须把标题的布局文件include进来，然后在代码里面<code>findViewById</code>来获取标题，还要设置标题<code>TextView</code>和标题前面小圆圈的主题什么的。<strong>这样你需要在每个使用这个标题的页面中都重复写这些代码</strong></p>
<p><strong>这样太麻烦了，你可以直接把它写成一个View，然后在布局文件中直接使用这个View</strong></p>
<pre><code>/**
 * 
 * @author bxbxbai
 * @version 1.0.0
 */
public class IndicatorView extends LinearLayout {

    TextView mTitle;

    public IndicatorView(Context context) {
        super(context);
        init();
    }

    public IndicatorView(Context context, AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    public IndicatorView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init();
    }

    private void init() {
        View view = View.inflate(getContext(), R.layout.find_song_title_bar, this);
        mTitle = (TextView) view.findViewById(R.id.id_text_title);
    }

    public void setTitle(String title) {
        mTitle.setText(title);
    }
}
</code></pre><h1 id="1-正方形的Layout"><a href="#1-正方形的Layout" class="headerlink" title="1. 正方形的Layout"></a>1. 正方形的Layout</h1><p>有很多情况会出现正方形的View，如下图：<br><img src="http://i3.tietuku.com/5664961aea30a6e4.png" alt="Square Post"></p>
<p>这样的布局一般会是最外面一个<code>LinearLayout</code>，包含一个<code>RelativeLayout</code>和一个<code>TextView</code>，这个<code>RelativeLayout</code>中包含了一个<code>ImageView</code>和两个<code>TextView</code>。如果把<code>ImageView</code>的<code>layout_height</code>设置成<code>wrap_content</code>，这样肯定会有问题，有的时候图片不是正方形的，就会有各种奇形怪状。</p>
<p>你也可以在加载图片的时候将Bitmap的高剪成和宽一致，但是这样太麻烦了。你也可以写一个<code>SqaureImageView</code>，但是我觉得这样的重用性不好。</p>
<p>其实，最好的方式还是将这个<code>RelativeLayout</code>换成<code>SquareLayout</code>，这是一个正方形的<code>RelativeLayout</code>。然后将<code>ImageView</code>的<code>layout_height</code>和<code>layout_width</code>设置成<code>match_parent</code>就可以了，图片自动设置为正方形，再按照需求设置<code>ImageView</code>的<code>scaleType</code></p>
<p>代码很少，如下：</p>
<pre><code>/**
 * Created by baia on 14/10/27.
 * @author bxbxbai
 * @version 1.0.0
 */
public class SquareLayout extends RelativeLayout {

    public SquareLayout(Context context) {
        super(context);
    }

    public SquareLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public SquareLayout(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        setMeasuredDimension(getDefaultSize(0, widthMeasureSpec), getDefaultSize(0, heightMeasureSpec));

        //children are just made to fill our space
        int childWithSize = getMeasuredWidth();

        //height is set to be same as width
        heightMeasureSpec = widthMeasureSpec =
                MeasureSpec.makeMeasureSpec(childWithSize, MeasureSpec.EXACTLY);

        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    }
}
</code></pre><h1 id="2-LinearLayout-的divider"><a href="#2-LinearLayout-的divider" class="headerlink" title="2. LinearLayout 的divider"></a>2. LinearLayout 的divider</h1><p>先来看一张图：<br><img src="http://i3.tietuku.com/54a6e2b531d34aca.png" alt="LinearLayout 的divider"></p>
<p>如果要写上面图片中的布局，整体的布局肯定是两个<code>LinearLayout</code>，然后设置margin值让各个子View之间留出空隙。如果你设置了button_2隐藏了，然后你就看到了：</p>
<p><img src="http://i3.tietuku.com/85e99608e72b54e0.png" alt="此处输入图片的描述"></p>
<p><strong>图片中button_1右边留出了一个margin值</strong></p>
<p>如果你使用<code>LinearLayout</code>的<code>android:divider</code>属性就会极大的方便你的代码。<code>android:divider</code>的值是一个<code>drawable</code>，你可以定义一个如下drawable文件</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/ 
    android:shape=&quot;rectangle&quot;&gt;
    &lt;size
        android:width=&quot;10dp&quot;
        android:height=&quot;10dp&quot; /&gt;
    &lt;solid android:color=&quot;@android:color/transparent&quot; /&gt;
&lt;/shape&gt;
</code></pre><p>其中，下面3个按钮的布局文件为：</p>
<pre><code>&lt;LinearLayout
    android:id=&quot;@+id/buttons_container&quot;
    android:layout_width=&quot;match_parent&quot;
    android:divider=&quot;@drawable/drawable_divider&quot;
    android:showDividers=&quot;middle&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:orientation=&quot;horizontal&quot;&gt;

    &lt;Button
        android:id=&quot;@+id/btn_0&quot;
        style=&quot;@style/ButtonStyle&quot;
        android:background=&quot;@android:color/holo_purple&quot;
        android:text=&quot;button_0&quot; /&gt;

    &lt;Button
        android:id=&quot;@+id/btn_1&quot;
        style=&quot;@style/ButtonStyle&quot;
        android:background=&quot;@android:color/darker_gray&quot;
        android:text=&quot;button_1&quot; /&gt;

    &lt;Button
        android:id=&quot;@+id/btn_3&quot;
        style=&quot;@style/ButtonStyle&quot;
        android:background=&quot;@android:color/holo_blue_dark&quot;
        android:text=&quot;button_2&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre><p>比较重要的两句代码就是：</p>
<pre><code>android:divider=&quot;@drawable/drawable_divider&quot;
android:showDividers=&quot;middle&quot;
</code></pre><p>这个<code>@drawable/drawable_divider</code>就是上面写的drawable文件，<code>showDividers</code>的值可以选择<code>beginning</code>, <code>middle</code>, <code>end</code>, <code>none</code>，什么意思一看就明白。</p>
<p><strong><code>LinearLayout</code>的<code>android:divider</code>是一个非常好用而且强大的功能噢～</strong></p>
<h1 id="3-更加方便的启动Fragment或Activity"><a href="#3-更加方便的启动Fragment或Activity" class="headerlink" title="3. 更加方便的启动Fragment或Activity"></a>3. 更加方便的启动Fragment或Activity</h1><p>启动Activity的一个非常普遍的方法就是</p>
<pre><code>Intent intent = new Intent(MainActivity.this, AlbumActivity.class);
intent.putExtra(ALBUM_ID, 100L);
startActivity(intent);
</code></pre><p>如果app中有很多地方会启动<code>AlbumActivity</code>，那么这样的话你就需要在很多地方重复上面的代码，这不是在<strong>Repeat Yourself</strong>了吗。不光如此，如果一个Activity需要很多值，那么你就需要一个一个的设置，非常麻烦。</p>
<p>换个思路，你可以这样写：</p>
<pre><code>public class AlbumActivity extends Activity {
    //....

    /**
     * launch activity
     * @param context Context
     * @param albumId id
    */
    public static void launch(Context context, long albumId) {
        Intent intent = new Intent(context, AlbumActivity.class);
        intent.putExtra(ALBUM_ID, albumId);
        context.startActivity(intent);
    }

    //...
}
</code></pre><p>然后你就可以直接这样启动<code>AlbumActivity</code>：</p>
<pre><code>AlbumActivity.launch(MainActivity.this, 100L);
</code></pre><p>其实启动Fragment也可以使用这样的方法，超级方便。</p>
<p><strong>我一直觉得，我写一个Fragment或Activity是希望别人以更加方便的方式去调用，而不是别人要用我的组件的时候先要看半天代码，这样很浪费时间</strong></p>
<h1 id="4-ListView的layout-height属性"><a href="#4-ListView的layout-height属性" class="headerlink" title="4. ListView的layout_height属性"></a>4. ListView的layout_height属性</h1><p>ListView的<code>layout_height</code>属性一般情况下不允许设置为<code>wrap_content</code>，这样会在ListView滚动的时候非常浪费性能（getView方法会多次调用）</p>
<h1 id="5-Singleton模板"><a href="#5-Singleton模板" class="headerlink" title="5. Singleton模板"></a>5. Singleton模板</h1><p>在看Android源码的时候发现这么一个类：</p>
<pre><code>package android.util;

/**
 * Singleton helper class for lazily initialization.
 *
 * Modeled after frameworks/base/include/utils/Singleton.h
 *
 * @hide
 */
public abstract class Singleton&lt;T&gt; {
    private T mInstance;

    protected abstract T create();

    public final T get() {
        synchronized (this) {
            if (mInstance == null) {
                mInstance = create();
            }
            return mInstance;
        }
    }
}
</code></pre><p>突然发现这个代码写的真好啊啊…如果你想创建一个单例的话只要继承这个<code>Singleton&lt;T&gt;</code>模板就可以了</p>
<p>但是！因为Android系统源码上加了<code>@hide</code>标注，我们不能直接继承这个<code>android.util.Singleton&lt;T&gt;</code>类。</p>
<p><strong> 我们可以在工程的utils包中写一份一模一样的代码嘛～ </strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些好用的开发技巧&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
      <category term="Note" scheme="http://bxbxbai.gitcafe.io/tags/Note/"/>
    
      <category term="开发经验" scheme="http://bxbxbai.gitcafe.io/tags/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>我的2014</title>
    <link href="http://bxbxbai.gitcafe.io/2015/01/13/my-2014/"/>
    <id>http://bxbxbai.gitcafe.io/2015/01/13/my-2014/</id>
    <published>2015-01-13T12:56:20.000Z</published>
    <updated>2016-02-29T07:54:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2014，对我来说是非常重要的一年。"><a href="#2014，对我来说是非常重要的一年。" class="headerlink" title="2014，对我来说是非常重要的一年。"></a><strong>2014，对我来说是非常重要的一年。</strong></h3><p>因为这一年我研究生毕业，然后在上海工作了。2014年春节过完我就来公司报道了，话说我也在公司待了将近一年了。学到了很多，总结了很多，并且也收获了很多</p>
<a id="more"></a>
<p>一开始，分到任务的时候我就会去想各种解决方法，那时的我唯一的一个想法就是将这个功能完成或bug改掉。后来时间长了以后，我就对客户端的代码慢慢开始熟悉，从界面到各种模块，然后又逐渐熟悉了如何加载图片如何发送HTTP请求，再到各种ContentProvider，从整体上对客户端的代码有了一个认识，这个时候我已经积累了一些经验</p>
<p>后来大家又开始专门对客户端的性能进行优化，我开始熟悉在线歌曲列表的代码的一些细节，并且对歌曲列表滑动的卡顿问题进行优化，慢慢的我也自己学会了使用TraceView工具，也顺便写了一篇<a href="http://bxbxbai.gitcafe.io/2014/10/25/use-trace-view/">文章</a>，这篇文章也在<a href="http://www.weibo.com/5038680568/BuUa9wzgv" target="_blank" rel="external">微博上</a>也一些人转发过</p>
<p>因为需求不断变的复杂，我开始对代码的重用性和可维护性有了认识，代码的可重用性高可以直接提高我们开发的效率，因为有些前面有人开发过的功能可以直接拿来使用。因此，我现在提交的代码也会考虑一些可重用的问题。</p>
<p>2014年这大半年的时间里，我觉得我最大的收获就是，<strong>在做一个新的功能或改一个bug 的时候，应该要想一想还有没有更好的解决办法了？</strong> 这个解决办法在以后需求改动时，够不够灵活，能不能重用以前的代码。如果面对一个新的需求的时候，最好要想到两种以上的解决方案，然后衡量每种方案实现的难易程度，如果以后需求改动，这种方案的改动会不会很麻烦（也就是扩展性和灵活性如何）。综合个方面来选择一个比较好的方案</p>
<p>利用大把的周末时间，我也看了一些大牛的代码，比如Volley和Picasso，有<a href="http://bxbxbai.gitcafe.io/2014/12/24/read-volley-source-code/">很多收获</a>。也自学了如何反编译，反编译了一些客户端来研究他们的架构和某些功能的实现，这一年我的一个主要思考的问题就是，<strong>如何架构一个易于扩展，并且代码重用性高的app</strong>。同时也集合了一些我觉得很好的开源项目，学习他们的代码</p>
<p>这一年也马马虎虎读了几本好书。比如《文明之光》系列（第3本才刚买来呢）、《图解HTTP》、《简约至上——交互设计四策略》、《程序员的思维修炼》、《参与感》，重新看了一遍《暗时间》。《文明之光》系列是吴军博士最新的书，2014年春节我重读了《浪潮之巅》觉得实在太精彩了！《文明之光》目前也只读了两本，非常好看，文笔非常朴实。</p>
<p>另外，在番薯同学的带领下，成为了一名菜驴。在这里要感谢番薯同学！2015要更多的参加户外徒步，更加多的运动</p>
<p>###<strong>2015的计划：</strong></p>
<ul>
<li>首要任务就是，继续深入Android开发，更加深入理解Android 4大组件，熟悉Android的运行原理，建立Android开发的整体框架（包括自定义View，动画），Android开发软件架构，如何去设计一个代码重用高，性能也高的app</li>
<li>学习Material Design，学习有关Material Design的开源库</li>
<li>看8-10本好书，学习互联网金融相关知识</li>
<li>更多的运动，一定要买一辆自行车；多参加户外运动，去一次台湾</li>
</ul>
<p><strong>最后，思考和总结是一个人进步的重要品质</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;2014，对我来说是非常重要的一年。&quot;&gt;&lt;a href=&quot;#2014，对我来说是非常重要的一年。&quot; class=&quot;headerlink&quot; title=&quot;2014，对我来说是非常重要的一年。&quot;&gt;&lt;/a&gt;&lt;strong&gt;2014，对我来说是非常重要的一年。&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;因为这一年我研究生毕业，然后在上海工作了。2014年春节过完我就来公司报道了，话说我也在公司待了将近一年了。学到了很多，总结了很多，并且也收获了很多&lt;/p&gt;
    
    </summary>
    
    
      <category term="2014" scheme="http://bxbxbai.gitcafe.io/tags/2014/"/>
    
  </entry>
  
  <entry>
    <title>Volley源码分析</title>
    <link href="http://bxbxbai.gitcafe.io/2014/12/24/read-volley-source-code/"/>
    <id>http://bxbxbai.gitcafe.io/2014/12/24/read-volley-source-code/</id>
    <published>2014-12-24T07:50:22.000Z</published>
    <updated>2015-09-12T07:01:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>Volley是一个可以让你在Android应用中以非常简单的方式来发送http请求并且处理服务器返回的数据，这样你就可以花更多的时间关心你的业务实现了</p>
<p>前段时间用了一下Volley，发现非常好用，就很好奇Volley是怎么实现的，因为它是Google的人开发的，也好奇大牛们写的代码都是怎么样的？抱着学习的心态来分析一下Volley的源码，也可以为我以后的工作中积累一些好用的解决方案。以后我也会看一下<a href="http://loopj.com/android-async-http/" target="_blank" rel="external">Android-async-http-client</a>是如何来处理发送http请求这类问题的</p>
<p>Volley的使用可以看这篇博客：<a href="http://bxbxbai.github.io/2014/09/14/android-working-with-volley/" target="_blank" rel="external">Volley库的使用介绍</a> ，你可以在这篇博客中找到更多关于Volley的学习资料：<a href="http://bxbxbai.github.io/2014/10/07/android-develop-resource/" target="_blank" rel="external">Android开发资源</a></p>
<a id="more"></a>
<p><strong>首先说明一下，在Volley中每发送一个请求都需要创建一个<code>Request</code>对象，然后将这个<code>Request</code>放入一个<code>RequestQueue</code>中，然后Volley会自动帮你处理这个<code>Request</code></strong>，你只需要处理返回的结果即可</p>
<p>从Volley的源码中可以看出，Volley就是实现了一个生产者消费者问题（<a href="http://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem" target="_blank" rel="external">Producer–consumer problem</a>）。从源码里看，一个消费者（<code>CacheDispatcher</code>）也可以是下一个消费者（<code>NetworkDispatcher</code>）的生产者</p>
<p>##0x0 Volley架构<br>总的来说Volley库的架构非常清晰，源代码也非常好理解，Volley的架构可以用下面这张图来说明：</p>
<p><img src="http://bxbxbai.github.io/img/volley.png" alt="volley"></p>
<p>这张图是Google I/O 2013 大会上演讲的图，我是从Youtube的视频上截下来的。</p>
<p>从这张图上可以很清晰的看见，一个Request被放到RequestQueue中后，马上被<code>CacheDispatcher</code>处理，从名字就可以看出来这是检查Cache的，如果Cache中有数据并且没过期的话Volley就直接将数据返回了</p>
<p>如果<code>CacheDispatcher</code>中没有数据或，数据已经过期了，那么Volley就通过<code>NetworkDispatcher</code>发送一个http请求来获取最新的数据，从图中可以看出有多个线程来发送http请求，也就是说Volley可以同时发送多个http请求</p>
<p>##0x1<br>上面将了Volley处理一个<code>Request</code>的大致流程，那么从源码角度来看Volley是怎么处理的呢？</p>
<p>###0x10 Request<t>类<br>首先来看一下Volley的<code>Request</code>类的签名：</t></p>
<pre><code>public abstract class Request&lt;T&gt; implements Comparable&lt;Request&lt;T&gt;&gt;
</code></pre><p><code>Request</code>是一个范型，其中<code>T</code>表示这个<code>Request</code>返回的数据类型，并且这个<code>Request</code>是可以相互比较的（实现<code>Comparable</code>接口），<code>Request</code>类实现的<code>Comparable</code>接口就是比较两个<code>Request</code>的priority</p>
<p>Volley自带的<code>Request</code>包含了一下几个：</p>
<ul>
<li><code>ImageRequest</code></li>
<li><code>JsonArrayRequest</code></li>
<li><code>JsonObjectRequest</code></li>
<li><code>JsonRequest</code></li>
<li><code>StringRequest</code></li>
<li><code>ClearCacheRequest</code></li>
</ul>
<p>从字面上可以基本看出每个Request是用来干什么的。</p>
<p>你也可以自定义一个<code>Request&lt;T&gt;</code>，比如说你可以定义一个<code>GsonRequest&lt;T&gt;</code>，当Volley发送一个请求后返回的是一个Java对象（通过Gson将json字符串自动转换成一个Java对象），这样的话写代码就非常方便了</p>
<p>自定义一个<code>Request&lt;T&gt;</code>需要实现<code>Request</code>类的两个抽象方法：</p>
<ul>
<li><code>Response&lt;T&gt; parseNetworkResponse(NetworkResponse response)</code></li>
<li><code>void deliverResponse(T response)</code></li>
</ul>
<p>第一个方法用来说明如何解析这个Response，说白了就是将<code>NetworkResponse</code>转换成<code>Response</code>对象。比如<code>ImageRequest</code>类就是需要将reponse数据转换成一个Bitmap对象</p>
<p>第二个方法是用来告诉Volley如何传递这个解析以后的结果，一般是用一个<code>Response.Listener&lt;T&gt;</code>回调接口来传递这个结果</p>
<p>##0x2 RequestQueue<br>上面讲了如何使用<code>Request</code>类，现在讲讲<code>RequestQueue</code></p>
<p>创建一个<code>RequestQueue</code>，需要4个参数</p>
<ul>
<li><strong>Cache</strong>：Volley使用的缓存，默认是<code>DiskBasedCache</code>（这个Cache为了减少gc，自己实现了一个简单的序列化方法）</li>
<li><strong>Network</strong> ： 这个是<code>RequestQueue</code>用来发送http请求的工具，后面会详细讲</li>
<li><strong>发送http请求的线程数</strong>（默认是4个）：<code>NetworkDispatcher</code> 线程数量</li>
<li><strong>ResponseDelivery</strong> ：用于传递Response，一般是被<code>CacheDispatcher</code>和<code>NetworkDispatcher</code>用于传递从Cache中拿到的或Network返回的HTTP Response</li>
</ul>
<p>####RequestQueue包含的其他东西<br>上面讲的是Volley的<code>RequestQueue</code>可以传入的参数，一个<code>RequestQueue</code>还需要以下东西才能正常运行：</p>
<p><code>AtomicInteger mSequenceGenerator</code> 是一个序列号生成器，它为每一个加入到队列中的Request打上一个序列号</p>
<p><code>PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue</code> 表示在Cache队列中的Request，从最上面的图中可以看到，一个<code>Request</code>被加到队列中后，它首先就进入<code>mCacheQueue</code></p>
<p><code>PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue</code> 表示等待通过<code>Network</code>发送HTTP请求的<code>Request</code>队列。这个和上面的<code>mCacheQueue</code>都是一个优先队列，每一个加入到优先队列中的<code>Request</code>都会按照它的优先级进行排序（如果优先级一样的话，就通过<code>mSequenceGenerator</code>生成的序号进行排序，这部分代码在<code>Request.compareTo</code>中可以看到）</p>
<p><code>Set&lt;Request&lt;?&gt;&gt; mCurrentRequests</code> 是<code>RequestQueue</code>当前正在执行或正在等待的<code>Request</code>，在<code>mCacheQueue</code>或<code>mNetworkQueue</code>中的<code>Request</code>都会被存放到<code>mCurrentRequests</code>列表中。这个列表中的<code>Request</code>可以用来执行<code>RequestQueue.cancelAll</code>操作</p>
<p><code>Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests</code> 这个对象也很有意思，这个map的key是<code>Request</code>的cacheKay，value是一个对应这个cacheKey所有的<code>Request</code></p>
<p>###0x20 创建一个RequestQueue</p>
<p>一般创建一个<code>RequestQueue</code>的方法就是通过下面这句代码：</p>
<pre><code>RequestQueue queue = Volley.newRequestQueue(Context);
</code></pre><p>当然，如果你需要自定义的话，就可以通过<code>RequestQueue</code>的构造函数自己new一个<code>RequestQueue</code>。一般来说，一个app中有一个<code>RequestQueue</code>就够了，没必要生成多个队列，生成多个队列会浪费系统的线程资源</p>
<p>在创建一个<code>RequestQueue</code>的时候，Volley已经充分帮我们考虑了一些事情</p>
<p>Android中用来发送HTTP请求的类有<code>HttpUrlConnection</code>和<code>AndroidHttpClient</code>，一般会使用前者，因为Google对它做了很多优化，但是在Android Gingerbread（Android 2.3，API LEVEL = 9）以前，<code>HttpUrlConnection</code>会有一些bug，那么应该使用后者。那为什么不直接使用后者呢？因为Google对前者做了很多优化…=。=</p>
<p>Volley对此也做了相应的判断，Android 2.3以前使用<code>AndroidHttpClient</code>，Android 3.0之后使用<code>HttpUrlConnection</code>，这样就会有相对更好的性能，更节省流量(<a href="http://android-developers.blogspot.com/2011/09/androids-http-clients.html" target="_blank" rel="external">看这里</a>)</p>
<p><code>Network</code>接口对他们进行了封装，对<code>RequestQueue</code>而言只有<code>Network</code>接口，但是真正发送请求的地方在<code>HurlStack.performRequest</code>或<code>HttpClientStack.performRequest</code>方法中，前者使用<code>HttpUrlConnection</code>，后者使用<code>AndroidHttpClient</code></p>
<p>####好处<br><code>RequestQueue</code>只依赖于<code>Network</code>接口，而不依赖于实现，它不必关心<code>Network.performRequest</code>具体的实现方式</p>
<p>###0x21 启动和停止RequestQueue</p>
<p>在<code>RequestQueue</code>生成以后就需要调用<code>RequestQueue.start</code>方法启动</p>
<p><code>RequestQueue.start</code>方法就是启动每一个Dispatcher（每一个Dispatcher就是一个线程）</p>
<pre><code>/**
 * Starts the dispatchers in this queue.
 */
public void start() {
    stop();  // Make sure any currently running dispatchers are stopped.
    // Create the cache dispatcher and start it.
    mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);
    mCacheDispatcher.start();

    // Create network dispatchers (and corresponding threads) up to the pool size.
    for (int i = 0; i &lt; mDispatchers.length; i++) {
        NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,
                mCache, mDelivery);
        mDispatchers[i] = networkDispatcher;
        networkDispatcher.start();
    }
}
</code></pre><p>同理<code>RequestQueue.stop</code>方法就是停止每一个Dispatcher，代码就不贴了</p>
<p>###0x22 向RequestQueue中添加Request</p>
<p>每创建一个<code>Request</code>都需要通过<code>RequestQueue.add</code>方法添加到队列中。调用<code>RequestQueue</code>的<code>add</code>方法，这就是生产者消费者问题中，生产者（producer）向池子（queue）里面存放物品（goods），然后消费者从池子（queue）里拿东西</p>
<p>先看代码：</p>
<pre><code>/**
 * Adds a Request to the dispatch queue.
 * @param request The request to service
 * @return The passed-in request
 */
public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request) {
    // Tag the request as belonging to this queue and     add it to the set of current requests.
    request.setRequestQueue(this);
    // A
    synchronized (mCurrentRequests) {
        mCurrentRequests.add(request);
    }

    // Process requests in the order they are added.
    request.setSequence(getSequenceNumber());
    request.addMarker(&quot;add-to-queue&quot;);

    // If the request is uncacheable, skip the cache queue and go straight to the network.
    // B
    if (!request.shouldCache()) {
        mNetworkQueue.add(request);
        return request;
    }

    // Insert request into stage if there&apos;s already a request with the same cache key in flight.
    synchronized (mWaitingRequests) {
        String cacheKey = request.getCacheKey();
        // C
        if (mWaitingRequests.containsKey(cacheKey)) {
            // There is already a request in flight. Queue up.
            Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);
            if (stagedRequests == null) {
                stagedRequests = new LinkedList&lt;Request&lt;?&gt;&gt;();
            }
            stagedRequests.add(request);
            mWaitingRequests.put(cacheKey, stagedRequests);
            if (VolleyLog.DEBUG) {
                VolleyLog.v(&quot;Request for cacheKey=%s is in flight, putting on hold.&quot;, cacheKey);
            }
        } else {
            // Insert &apos;null&apos; queue for this cacheKey, indicating there is now a request in flight.
            // D
            mWaitingRequests.put(cacheKey, null);
            mCacheQueue.add(request);
        }
        return request;
    }
}
</code></pre><p>上面代码就是添加一个<code>Request</code>到队列中的全部操作。我加了A、B、C、D关键处标记，</p>
<ul>
<li><p>A : 首先，将<code>Request</code>加入到<code>mCurrentRequests</code>，表示有一个<code>Request</code>将要被处理，然后这是这个<code>Request</code>的序列号和一个测试标记</p>
</li>
<li><p>B : 检查这个<code>Request</code>是否可以被Cache，如果不可以，就直接放入<code>mNetworkQueue</code>中，由<code>NetworkDispatcher</code>处理，直接发送HTTP请求</p>
</li>
<li><p>C : 接下来，表示<code>Request</code>都可以被Cache的，检查<code>Request</code>的cacheKey字段，如果存在相同cacheKey的<code>Request</code>，就表示可以不处理这个<code>Request</code>了，直接拿别的<code>Request</code>的结果即可，这样可以减少相同<code>Request</code>的发送，减少流量消耗~</p>
</li>
<li><p>D : 如果C不满足的话，就将这个<code>Request</code>放入<code>mCacheQueue</code>队列中，由<code>CacheDispatcher</code>来处理 </p>
</li>
</ul>
<p>###0x23 如何传递Response</p>
<p>当<code>CacheDispatcher</code>或<code>NetworkDispatcher</code>拿到Response以后（不管是Cache中的还是请求HTTP返回的），都会通过一个叫做<code>ResponseDelivery</code>的东西传递出去。</p>
<p>其中，传递HTTP Response真正的地方就在<code>ResponseDelivery</code>的<code>ResponseDeliveryRunnable</code>类中，下面是<code>ResponseDeliveryRunnable</code>类的<code>run</code>方法：</p>
<pre><code> @Override
 public void run() {
     // If this request has canceled, finish it and don&apos;t deliver.
     if (mRequest.isCanceled()) {
         mRequest.finish(&quot;canceled-at-delivery&quot;);
         return;
     }

     // Deliver a normal response or error, depending.
     if (mResponse.isSuccess()) {
         mRequest.deliverResponse(mResponse.result);
     } else {
         mRequest.deliverError(mResponse.error);
     }

     // If this is an intermediate response, add a marker, otherwise we&apos;re done
     // and the request can be finished.
     if (mResponse.intermediate) {
         mRequest.addMarker(&quot;intermediate-response&quot;);
     } else {
         mRequest.finish(&quot;done&quot;);
     }

     // If we have been provided a post-delivery runnable, run it.
     if (mRunnable != null) {
         mRunnable.run();
     }
}
</code></pre><p>这个方法就会检查这个<code>Response</code>，如果<code>Response</code>是成功的，那么就通过<code>Request.deliverResponse</code>方法传递。</p>
<p>在本文最上面可以看到，<code>Request.deliverResponse</code>是一个抽象方法，每个<code>Request</code>都需要自己实现处理<code>Response</code>的代码，一般都是通过调用<code>Response.Listener</code> 接口来处理结果</p>
<p>##0x3 CacheDispatcher</p>
<p><code>CacheDispatcher</code>是一个专门用来检查Cache的线程，它其实既是消费者也是生产者。它需要以下几样东西：</p>
<ul>
<li><code>BlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue</code> ： 等待检查Cache 的Request队列</li>
<li><code>BlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue</code> ： 等待发送HTTP请求的Request队列</li>
<li><code>Cache mCache</code> ： Volley使用的Cache，默认就是<code>DiskBasedCache</code></li>
<li><code>ResponseDelivery mDelivery</code> ：如果检查的Cache符合要求（没有过期），就用这个来传递Response</li>
</ul>
<p>从上面图中可以看出，<code>CacheDispatcher</code>对于app来说是一个消费者，它从<code>mCacheQueue</code>中拿Request来检查Cache。对<code>NetworkDispatcher</code>来说，又是一个生产者（如果检查的Cache没有或者Cache已经过期，就向<code>mNetworkQueue</code>中添加Request）</p>
<p>下面就是<code>CacheDispatcher</code>的<code>run</code>方法，从源代码里看一看到<code>CacheDispatcher</code>会一直运行，当<code>mCacheQueue</code>中没有需要处理的<code>Request</code>时，此线程会一直被<code>mCacheQueue.take()</code>方法阻塞，直到<code>RequestQueue</code>向<code>mCacheQueue</code>添加了一个请求。</p>
<pre><code>@Override
public void run() {
    if (DEBUG) VolleyLog.v(&quot;start new dispatcher&quot;);
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);

    // Make a blocking call to initialize the cache.
    mCache.initialize();

    while (true) {
        try {
            // Get a request from the cache triage queue, blocking until
            // at least one is available.
            final Request&lt;?&gt; request = mCacheQueue.take();
            request.addMarker(&quot;cache-queue-take&quot;);

            // If the request has been canceled, don&apos;t bother dispatching it.
            if (request.isCanceled()) {
                request.finish(&quot;cache-discard-canceled&quot;);
                continue;
            }

            // Attempt to retrieve this item from cache.
            Cache.Entry entry = mCache.get(request.getCacheKey());
            if (entry == null) {
                request.addMarker(&quot;cache-miss&quot;);
                // Cache miss; send off to the network dispatcher.
                mNetworkQueue.put(request);
                continue;
            }

            // If it is completely expired, just send it to the network.
            if (entry.isExpired()) {
                request.addMarker(&quot;cache-hit-expired&quot;);
                request.setCacheEntry(entry);
                mNetworkQueue.put(request);
                continue;
            }

            // We have a cache hit; parse its data for delivery back to the request.
            request.addMarker(&quot;cache-hit&quot;);
            Response&lt;?&gt; response = request.parseNetworkResponse(
                    new NetworkResponse(entry.data, entry.responseHeaders));
            request.addMarker(&quot;cache-hit-parsed&quot;);

            if (!entry.refreshNeeded()) {
                // Completely unexpired cache hit. Just deliver the response.
                mDelivery.postResponse(request, response);
            } else {
                // Soft-expired cache hit. We can deliver the cached response,
                // but we need to also send the request to the network for
                // refreshing.
                request.addMarker(&quot;cache-hit-refresh-needed&quot;);
                request.setCacheEntry(entry);

                // Mark the response as intermediate.
                response.intermediate = true;

                // Post the intermediate response back to the user and have
                // the delivery then forward the request along to the network.
                mDelivery.postResponse(request, response, new Runnable() {
                    @Override
                    public void run() {
                        try {
                            mNetworkQueue.put(request);
                        } catch (InterruptedException e) {
                            // Not much we can do about this.
                        }
                    }
                });
            }

        } catch (InterruptedException e) {
            // We may have been interrupted because it was time to quit.
            if (mQuit) {
                return;
            }
            continue;
        }
    }
}
</code></pre><p>##0x4 NetworkDispatcher</p>
<p><code>NetworkDispatcher</code>和<code>CacheDispatcher</code>非常类似，它也需要4个东西：</p>
<ul>
<li><code>BlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue</code> ： 等待发送HTTP请求的Request队列</li>
<li><code>Network mNetwork</code> ： 用于发送HTTP请求的，<code>Network</code>是一个接口</li>
<li><code>Cache mCache</code> ： Volley使用的Cache，默认就是<code>DiskBasedCache</code></li>
<li><code>ResponseDelivery mDelivery</code> ：如果检查的Cache符合要求（没有过期），就用这个来传递Response</li>
</ul>
<p>其中操作的过程也和<code>CacheDispatcher</code>类似，就不贴源码了</p>
<p>##0x5 ImageLoader<br>上面讲的东西大致就构成了Volley库<strong>最核心</strong>的东西，一般的请求json或图片是没有太大问题的。但是Google的工程师又想到为我们广大码农减少工作量，增加了<code>ImageLoader</code>和<code>NetworkImageView</code>这两个东西</p>
<p>其实<code>ImageLoader</code>这个工具和Volley库的整个架构是没有太大关系的，它就是为了更加方便的让我们加载网络图片</p>
<p>创建一个<code>ImageLoader</code>需要两个东西：</p>
<ul>
<li>RequestQueue ： 这个在上面已经说了好多了</li>
<li>ImageCache ： 这是一个接口，Volley没有提供具体的实现，需要自己实现。一般都会实现一个基于内存的<code>LruImageCache</code>，网上也有各种栗子。可以参考<a href="http://square.github.io/picasso/" target="_blank" rel="external">Picasso</a>源码中的<a href="https://github.com/square/picasso/blob/master/picasso/src/main/java/com/squareup/picasso/LruCache.java" target="_blank" rel="external">实现</a></li>
</ul>
<p><code>ImageLoader</code>也是对<code>RequestQueue</code>的一个封装，它也会为创建一个<code>Request&lt;ImageView&gt;</code>，然后把这个Request放到RequestQueue中去下载图片</p>
<p>###0x50 在Volley中如何方便的加载一张图片</p>
<pre><code>ImageLoader loader = new ImageLoader(RequestQueue, ImageCache);
NetworkImageView imageView = (NetworkImageView)findViewById(R.id.iv_news_pic);
imageView.setImageUrl(picUrl, loader);
</code></pre><p>上面3句代码就能够加载网络图片了，是不是很方便。<code>NetworkImageView</code>会计算当前ImageView的宽高，然后创建一个ImageRequest，放入RequestQueue中下载图片。</p>
<p>###0x51 NetworkImageView</p>
<p><code>NetworkImageView</code>是继承<code>ImageView</code>的，比传统的<code>ImageView</code>多了一个加载网络图片的功能</p>
<p>##0x6 最后<br>本文就是详细的分析了Volley库的结构了流程。本文觉得这个库设计的非常好，不管是扩展性还是代码可读性都非常好。</p>
<p><code>RequestQueue</code>就表示Volley运行的整个生命周期，它维护了很多个队列。<code>CacheDispatcher</code>和<code>NetworkDispatcher</code> 分别完成检查Cache和发送HTTP请求的工作。当拿到<code>NetworkResponse</code>数据的时候，会调用<code>Request.parseNetworkResponse</code>方法解析Response结果，最后调用<code>ResponseDeleivery</code>对象来传递解析后的Response结果。</p>
<p>Google还在Volley中加入了<code>ImageLoader</code>和<code>NetworkImageView</code>让我们广大码农以更加方便的方式加载网络图片</p>
<p>###最后的最后</p>
<p>Volley的整个架构实现就是最基本的生产者消费者模式（<a href="http://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem" target="_blank" rel="external">Producer–consumer problem</a>）。这种架构虽然很简单，但是用途也非常广泛，非常值得学习和借鉴！！</p>
<p>也不是说Volley就完美了，最近本人又在学习<a href="http://square.github.io/picasso/" target="_blank" rel="external">Picasso</a>的源码。这是一个非常好的专门用于加载图片的库，它不光可以加载网络图片，还可以用它来加载res目录下的图片、SD卡上的图片、Asset目录下的图片、手机图片库中的图片，而且扩展性也非常好！不说了，下次有机会就写一篇关于<a href="http://square.github.io/picasso/" target="_blank" rel="external">Picasso</a>的源码分析博客</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Volley是一个可以让你在Android应用中以非常简单的方式来发送http请求并且处理服务器返回的数据，这样你就可以花更多的时间关心你的业务实现了&lt;/p&gt;
&lt;p&gt;前段时间用了一下Volley，发现非常好用，就很好奇Volley是怎么实现的，因为它是Google的人开发的，也好奇大牛们写的代码都是怎么样的？抱着学习的心态来分析一下Volley的源码，也可以为我以后的工作中积累一些好用的解决方案。以后我也会看一下&lt;a href=&quot;http://loopj.com/android-async-http/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android-async-http-client&lt;/a&gt;是如何来处理发送http请求这类问题的&lt;/p&gt;
&lt;p&gt;Volley的使用可以看这篇博客：&lt;a href=&quot;http://bxbxbai.github.io/2014/09/14/android-working-with-volley/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Volley库的使用介绍&lt;/a&gt; ，你可以在这篇博客中找到更多关于Volley的学习资料：&lt;a href=&quot;http://bxbxbai.github.io/2014/10/07/android-develop-resource/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android开发资源&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Volley 源码分析" scheme="http://bxbxbai.gitcafe.io/tags/Volley-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>LayoutInflater.inflate方法解析</title>
    <link href="http://bxbxbai.gitcafe.io/2014/11/19/make-sense-of-layoutinflater/"/>
    <id>http://bxbxbai.gitcafe.io/2014/11/19/make-sense-of-layoutinflater/</id>
    <published>2014-11-19T04:58:40.000Z</published>
    <updated>2015-09-12T07:01:41.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>LayoutInflater.inflate</code>方法应该是Android程序员最常使用的方法之一了，但是如果使用不当，你会碰见很多的坑。。。今天我就碰到了一个，我找到了解决方法，也打算把它记下来。。。</p>
<p>事情是这样的，我有一个<code>LineaLayout</code>，然后在代码中会<code>inflate</code>若干个<code>View</code>添加到这个<code>LineaLayout</code>中，但是坑出现了。。。</p>
<a id="more"></a>
<p>##0x00 一个栗子<br>需要添加到LinearLayout中的View布局文件类似如下（）：</p>
<pre><code>&lt;RelativeLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;80dp&quot;
    android:paddingTop=&quot;5dp&quot;
    android:paddingBottom=&quot;5dp&quot;
    android:background=&quot;@android:color/holo_green_dark&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;ImageView
        android:id=&quot;@+id/iv_media_menu_icon&quot;
        android:layout_height=&quot;24dp&quot;
        android:layout_width=&quot;24dp&quot;
        android:src=&quot;@drawable/ic_mv&quot;
        android:layout_centerHorizontal=&quot;true&quot;/&gt;
    &lt;TextView
        android:id=&quot;@+id/tv_media_menu_text&quot;
        android:text=&quot;bxbxbai&quot;
        style=&quot;@style/Menu_TextView&quot;/&gt;
&lt;/RelativeLayout&gt;
</code></pre><p>这个<code>View</code>的宽固定为<code>80dp</code>，高和父容器一样，然后就是<code>inflate</code>这个View并且添加到这个<code>LinearLayout</code>中（我故意将这个布局文件的background设置一个颜色，这样可以很清晰的看出这个View占的位置）</p>
<pre><code>LinearLayout layout = (LinearLayout)findViewById(R.id.container);
View view = View.inflate(this, R.layout.layout_menu_item, null);
layout.addView(view);
</code></pre><p>这样写的话，你就会发现布局文件<code>R.layout.layout_menu_item</code>中的<code>android:layout_width=&quot;80dp&quot;</code>不起作用！！也就是说<code>View.inflate</code>方法忽略了布局文件的宽度设置</p>
<p><img src="http://bxbxbai.github.io/img/inflate0.PNG" alt="inflate"></p>
<p>可是你又可以发现<code>View.inflate</code>方法中还有第三个参数<code>ViewGroup root</code>，Android文档中是这么写的：</p>
<blockquote>
<p>A view group will be the parent. Used to properly inflate the layout_* parameters</p>
</blockquote>
<p>那么可以猜想肯定和这个参数有关，下面改写代码：</p>
<pre><code>LinearLayout layout = (LinearLayout)findViewById(R.id.container);
View view = View.inflate(this, R.layout.layout_menu_item, layout);
layout.addView(view);
</code></pre><p>你就会发现这样写会崩溃！然后下面这样写就没问题了：</p>
<pre><code>LinearLayout layout = (LinearLayout)findViewById(R.id.container);
View view = View.inflate(this, R.layout.layout_menu_item, layout);
</code></pre><p><code>View.inflate</code>方法自动将生成的View添加到了这个<code>ViewGroup root</code>中去了！！</p>
<p><img src="http://bxbxbai.github.io/img/inflate1.PNG" alt="inflate"></p>
<p>你可以<code>inflate</code>多个View，就可以看到下面这样样子了：</p>
<p><img src="http://bxbxbai.github.io/img/inflate2.PNG" alt="inflate"></p>
<p>##0x01 inflate详解<br>其实<code>View.inflate</code>方法是调用了<code>LayoutInflater.from(context).inflate(resource, root, root != null)</code>方法，而inflate方法的三个参数如下：</p>
<ul>
<li>resource： 布局文件的id，比如<code>R.layout.layout_menu_item</code></li>
<li>root：这是一个可选参数，resource布局文件中<code>layout_*</code>参数设置的参照物就是这个root，也就是说<code>inflate</code>方法会根据这个root的大小，将resource布局文件中<code>layout_*</code>参数转换成一个<code>LayoutParam</code>对象</li>
<li>attachToRoot：是否将这个生成的View添加到这个root中去</li>
</ul>
<p><code>inflate</code>方法会返回resource布局文件产生的View</p>
<p>上面栗子中调用了<code>View.inflate(Context context, int resource, ViewGroup root)</code>，这个方法本质上是调用了了<code>LayoutInflater.from(context).inflate(resource, root, root != null)</code>，在这个<code>inflate</code>方法中可以找到下面代码：</p>
<pre><code>// We are supposed to attach all the views we found (int temp)
// to root. Do that now.
if (root != null &amp;&amp; attachToRoot) {
    root.addView(temp, params);
}
</code></pre><p>可见<code>inflate</code>方法自动将这个生成的<code>View</code>添加到了这个<code>root</code>中去了</p>
<p>##0x02 实验</p>
<p>因为可以调用<code>inflate</code>方法的途径有很多，下面就来做实验总结一下：</p>
<p>###实验0<br>布局文件<code>R.layout.layout_menu_item</code> 中<code>android:layout_height=&quot;match_parent&quot;</code> 改为<code>android:layout_height=&quot;10dp&quot;</code></p>
<pre><code>LinearLayout layout = (LinearLayout)findViewById(R.id.container);
View v1 = LayoutInflater.from(this).inflate(R.layout.layout_menu_item, null);
layout.addView(v1);

// 结果: layout_height = match_parent layout_width = match_parent
</code></pre><p><img src="http://bxbxbai.github.io/img/inflate_expriment_0.PNG" alt="inflate"></p>
<p>###实验1<br>布局文件<code>R.layout.layout_menu_item</code> 中<code>android:layout_height=&quot;match_parent&quot;</code> 改为<code>android:layout_height=&quot;10dp&quot;</code></p>
<pre><code>LinearLayout layout = (LinearLayout)findViewById(R.id.container);
View v1 = LayoutInflater.from(this).inflate(R.layout.layout_menu_item, null);
layout.addView(v1, 200, 200);

// 结果: layout_height = 200 layout_width = 200
</code></pre><p><img src="http://bxbxbai.github.io/img/inflate_expriment_1.PNG" alt="inflate"></p>
<p>###实验2<br>布局文件<code>R.layout.layout_menu_item</code> 中<code>android:layout_height</code>值改为<code>match_parent</code> </p>
<pre><code>LinearLayout layout = (LinearLayout)findViewById(R.id.container);
View v1 = LayoutInflater.from(this).inflate(R.layout.layout_menu_item, layout, false);
layout.addView(v1);

// 结果: layout_height = match_parent layout_width = 80dp
// v1 = RelativeLayout 因为 attachRoot = false
</code></pre><p><img src="http://bxbxbai.github.io/img/inflate_expriment_2.PNG" alt="inflate"></p>
<p>###实验3<br>布局文件<code>R.layout.layout_menu_item</code> 中<code>android:layout_height</code>值改为<code>match_parent</code> </p>
<pre><code>LinearLayout layout = (LinearLayout)findViewById(R.id.container);
View v1 = LayoutInflater.from(this).inflate(R.layout.layout_menu_item, layout, true);
//layout.addView(v1);

// 结果: layout_height = match_parent layout_width = 80dp
// 不需要layout.addView, 因为设置attachRoot=true, 生成的View自动添加到root中去了
// v1 = root 因为 attachRoot = true
</code></pre><p>##0x03 源码分析</p>
<pre><code><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span>(<span class="params">XmlPullParser parser, ViewGroup root, boolean attachToRoot</span>) </span>&#123;</div><div class="line">    synchronized (mConstructorArgs) &#123;</div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"inflate"</span>);</div><div class="line"></div><div class="line">        final AttributeSet attrs = Xml.asAttributeSet(parser);</div><div class="line">        Context lastContext = (Context)mConstructorArgs[<span class="number">0</span>];</div><div class="line">        mConstructorArgs[<span class="number">0</span>] = mContext;</div><div class="line">        View result = root;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// Look for the root node.</span></div><div class="line">            <span class="keyword">int</span> type;</div><div class="line">            <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</div><div class="line">                    type != XmlPullParser.END_DOCUMENT) &#123;</div><div class="line">                <span class="comment">// Empty</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(parser.getPositionDescription()</div><div class="line">                        + <span class="string">": No start tag found!"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            final String name = parser.getName();</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">                System.<span class="keyword">out</span>.println(<span class="string">"**************************"</span>);</div><div class="line">                System.<span class="keyword">out</span>.println(<span class="string">"Creating root view: "</span></div><div class="line">                        + name);</div><div class="line">                System.<span class="keyword">out</span>.println(<span class="string">"**************************"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (TAG_MERGE.<span class="keyword">equals</span>(name)) &#123;</div><div class="line">                <span class="keyword">if</span> (root == <span class="literal">null</span> || !attachToRoot) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"&lt;merge /&gt; can be used only with a valid "</span></div><div class="line">                            + <span class="string">"ViewGroup root and attachToRoot=true"</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                rInflate(parser, root, attrs, <span class="literal">false</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// Temp is the root view that was found in the xml</span></div><div class="line">                View temp;</div><div class="line">                <span class="keyword">if</span> (TAG_1995.<span class="keyword">equals</span>(name)) &#123;</div><div class="line">                    temp = <span class="keyword">new</span> BlinkLayout(mContext, attrs);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    temp = createViewFromTag(root, name, attrs);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                ViewGroup.LayoutParams <span class="keyword">params</span> = <span class="literal">null</span>;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">                        System.<span class="keyword">out</span>.println(<span class="string">"Creating params from root: "</span> +</div><div class="line">                                root);</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// Create layout params that match root, if supplied</span></div><div class="line">                    <span class="keyword">params</span> = root.generateLayoutParams(attrs);</div><div class="line">                    <span class="keyword">if</span> (!attachToRoot) &#123;</div><div class="line">                        <span class="comment">// Set the layout params for temp if we are not</span></div><div class="line">                        <span class="comment">// attaching. (If we are, we use addView, below)</span></div><div class="line">                        temp.setLayoutParams(<span class="keyword">params</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">                    System.<span class="keyword">out</span>.println(<span class="string">"-----&gt; start inflating children"</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// Inflate all children under temp</span></div><div class="line">                rInflate(parser, temp, attrs, <span class="literal">true</span>);</div><div class="line">                <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">                    System.<span class="keyword">out</span>.println(<span class="string">"-----&gt; done inflating children"</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// We are supposed to attach all the views we found (int temp)</span></div><div class="line">                <span class="comment">// to root. Do that now.</span></div><div class="line">                <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; attachToRoot) &#123;</div><div class="line">                    root.addView(temp, <span class="keyword">params</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Decide whether to return the root that was passed in or the</span></div><div class="line">                <span class="comment">// top view found in xml.</span></div><div class="line">                <span class="keyword">if</span> (root == <span class="literal">null</span> || !attachToRoot) &#123;</div><div class="line">                    result = temp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</div><div class="line">            InflateException ex = <span class="keyword">new</span> InflateException(e.getMessage());</div><div class="line">            ex.initCause(e);</div><div class="line">            <span class="keyword">throw</span> ex;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            InflateException ex = <span class="keyword">new</span> InflateException(</div><div class="line">                    parser.getPositionDescription()</div><div class="line">                    + <span class="string">": "</span> + e.getMessage());</div><div class="line">            ex.initCause(e);</div><div class="line">            <span class="keyword">throw</span> ex;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">// Don't retain static reference on context.</span></div><div class="line">            mConstructorArgs[<span class="number">0</span>] = lastContext;</div><div class="line">            mConstructorArgs[<span class="number">1</span>] = <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>实验3的原因在<strong>inflate详解</strong>中已经介绍过了。</p>
<p>总之原因就在上面代码<code>71-74</code>行，布局文件<code>R.layout.layout_menu_item</code>生成的View会因为<code>attachToRoot</code>参数为<code>true</code>，就将这个生成的<code>View</code>添加到<code>root</code>中去，然后<code>inflate</code>方法会返回这个<code>root</code>的<code>View</code></p>
<p>看上面代码<code>54-60</code>行，如果root不为null的话，就会为这个布局文件<code>R.layout.layout_menu_item</code>生成一个<code>LayoutParam</code>对象，如果<code>attachToRoot</code>参数为<code>false</code>，那么就将这个<code>param</code>对象给这个布局文件的View（看55行）。如果<code>attachToRoot</code>参数为<code>true</code>，那么就在上面代码第70行，将这个布局文件的<code>View</code>和<code>param</code>参数添加到<code>root</code>中。</p>
<p>##0x04 总结</p>
<ol>
<li><p>调用<code>LayoutInflater.inflate</code>方法，并且将root参数设置为<code>null</code>，就等于忽略了xml布局文件中的<code>layout_×</code>参数</p>
</li>
<li><p>如果<code>root</code>不为<code>null</code>，并且<code>attachRoot=true</code>，那么就会根据<code>root</code>生成一个布局文<code>件View</code>的<code>LayoutParam</code>对象，并且将这个<code>View</code>添加到<code>root</code>中去，并且返回这个<code>root</code>的<code>View</code></p>
</li>
<li><p>因此，最好还是使用这个代码吧：<code>View v1 = LayoutInflater.from(this).inflate(R.layout.layout_menu_item, layout, false);</code></p>
</li>
</ol>
<p>##参考</p>
<ol>
<li><p><a href="http://stackoverflow.com/questions/5026926/making-sense-of-layoutinflater" target="_blank" rel="external">Making sense of LayoutInflater</a></p>
</li>
<li><p><a href="http://www.doubleencore.com/2013/05/layout-inflation-as-intended/" target="_blank" rel="external">Layout Inflation as Intended</a></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;LayoutInflater.inflate&lt;/code&gt;方法应该是Android程序员最常使用的方法之一了，但是如果使用不当，你会碰见很多的坑。。。今天我就碰到了一个，我找到了解决方法，也打算把它记下来。。。&lt;/p&gt;
&lt;p&gt;事情是这样的，我有一个&lt;code&gt;LineaLayout&lt;/code&gt;，然后在代码中会&lt;code&gt;inflate&lt;/code&gt;若干个&lt;code&gt;View&lt;/code&gt;添加到这个&lt;code&gt;LineaLayout&lt;/code&gt;中，但是坑出现了。。。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://bxbxbai.gitcafe.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
      <category term="开发技巧" scheme="http://bxbxbai.gitcafe.io/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
      <category term="经验" scheme="http://bxbxbai.gitcafe.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>正确使用Android性能分析工具——TraceView</title>
    <link href="http://bxbxbai.gitcafe.io/2014/10/25/use-trace-view/"/>
    <id>http://bxbxbai.gitcafe.io/2014/10/25/use-trace-view/</id>
    <published>2014-10-25T02:09:36.000Z</published>
    <updated>2016-03-12T06:59:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前面唠叨"><a href="#前面唠叨" class="headerlink" title="前面唠叨"></a>前面唠叨</h2><p>最近公司app中有些列表在滑动的时候会有卡顿现象，我就开始着手解决这些问题，解决问题之前首先要分析列表滑动的性能瓶颈在什么地方。因为之前不会正确使用TraceView这个工具，主要是看不懂TraceView界面下方数据指标的值代表什么意思…以前我用<a href="http://bxbxbai.github.io/2014/08/01/the-stopwatch-class/" target="_blank" rel="external">StopWatch</a>类来分析性能，现在觉得弱爆了…不过有些地方<a href="http://bxbxbai.github.io/2014/08/01/the-stopwatch-class/" target="_blank" rel="external">StopWatch</a>工具类还是很简单好用的~</p>
<p>网上可以找了很多博客来介绍这个工具的使用方法，很多都是讲解了一些一些就会的方法，讲一个大概，包括StackOverFlow上我也没有找到很好的讲解TraceView各个数据指标代码什么意思的回答</p>
<p>因为我要解决列表滑动的卡顿问题，就必须要找到导致卡顿现象的原因，我就在StackOverFlow上找着别人零散的回答慢慢琢磨这个工具的使用方法。现在我学会了，至少能看懂每个指标什么意思，<strong>最后发现这个工具实在太强大了！！！</strong></p>
<a id="more"></a>
<h2 id="TraceView界面"><a href="#TraceView界面" class="headerlink" title="TraceView界面"></a>TraceView界面</h2><p>现来看一下整个界面的图，整个界面包括上下两部分，上面是你测试的进程中每个线程的执行情况，每个线程占一行；下面是每个方法执行的各个指标的值</p>
<p>上面一部分是你测试进程的中每个线程运行的时间线，下图中可以可以看到，主要只有一个main线程在执行，因为我滑动了一下列表，main线程（UI线程）正在进行绘制View呢~~</p>
<p>然后我点击了序号为133的一个方法<code>io.bxbxbai.android.examples.activity.ExpandableLayoutMainActivity$SimpleAdapter.getItemView</code>，就会出现两部分数据：</p>
<ul>
<li>Parents</li>
<li>Children</li>
</ul>
<p>Parents表示调用133这个方法的父方法，可以看到序号为130。Children表示方法133调用的其他方法，可以看到有好几个方法。</p>
<p><img src="http://bxbxbai.github.io/img/trace_view.png" alt="main"></p>
<h2 id="如何使用TraceView"><a href="#如何使用TraceView" class="headerlink" title="如何使用TraceView"></a>如何使用TraceView</h2><p>因为这次我主要是分析列表滑动卡顿问题，我就讲讲我是怎么使用这个工具的，并且我是怎么分析的。</p>
<p>使用TraceView主要有两种方式：</p>
<ol>
<li><p>最简单的方式就是直接打开DDMS，选择一个进程，然后按上面的“Start Method Profiling”按钮，等红色小点变成黑色以后就表示TraceView已经开始工作了。然后我就可以滑动一下列表（现在手机上的操作肯定会很卡，因为Android系统在检测Dalvik虚拟机中每个Java方法的调用，这是我猜测的）。<strong>操作最好不要超过5s，因为最好是进行小范围的性能测试</strong>。然后再按一下刚才按的按钮，等一会就会出现上面这幅图，然后就可以开始分析了。</p>
</li>
<li><p>第2种方式就是使用<code>android.os.Debug.startMethodTracing();</code>和<code>android.os.Debug.stopMethodTracing();</code>方法，当运行了这段代码的时候，就会有一个trace文件在<code>/sdcard</code>目录中生成，也可以调用<code>startMethodTracing(String traceName)</code> 设置trace文件的文件名，最后你可以使用<code>adb pull /sdcard/test.trace /tmp</code> 命令将trace文件复制到你的电脑中，然后用DDMS工具打开就会出现第一幅图了</p>
</li>
</ol>
<p>第一种方式相对来说是一种简单，但是测试的范围很宽泛，第二中方式相对来说精确一点，不过我个人喜欢使用第一种，因为简单，而且它是检测你的某一个<strong>操作</strong>。因为第二中更适合检测某一个方法的性能，其实也没有那种好，看使用的场景和喜好了。。。</p>
<h2 id="看懂TraceView中的指标"><a href="#看懂TraceView中的指标" class="headerlink" title="看懂TraceView中的指标"></a>看懂TraceView中的指标</h2><p><img src="http://bxbxbai.github.io/img/trace_view_metric.png" alt="指标"></p>
<p>其实我今年7月份就已经开始使用TraceView工具了，但是当时不懂其中每个指标的含义，就没注意到它强大的地方。看不懂界面下方表格中的指标，这些数据其实一点意义都没有。</p>
<p>网上包括Android官网也没有对TraceView工具的使用有详细的说明文档，这点确实比较蛋疼。</p>
<p>###纵轴<br>TraceView界面下方表格中纵轴就是每个方法，包括了JDK的，Android SDK的，也有native方法的，当然最重要的就是app中你自己写的方法，有些Android系统的方法执行时间很长，那么有很大的可能就是你app中调用这些方法过多导致的。</p>
<p><strong>每个方法前面都有一个数字，可能是全部方法按照Incl CPU Time 时间的排序序号</strong>（后面会讲到）</p>
<p>点一个方法后可以看到有两部分，一个是Parents，另一个是Children。</p>
<ul>
<li><p>Parent表示调用这个方法的方法，可以叫做父方法</p>
</li>
<li><p>Children表示这个方法中调用的其他方法，可以叫做子方法</p>
</li>
</ul>
<h3 id="横轴"><a href="#横轴" class="headerlink" title="横轴"></a>横轴</h3><p><img src="http://bxbxbai.github.io/img/trace_view_incl_time.png" alt="incl time"></p>
<p>横轴上是很多指标，这些指标表示什么意思真的困扰了我很长一段时间。。。</p>
<p>能够很衡量一个方法性能的指标应该只有时间了吧？ 一个方法肯定就是执行时间越短约好咯~~</p>
<h4 id="1-Incl-Cpu-Time"><a href="#1-Incl-Cpu-Time" class="headerlink" title="1. Incl Cpu Time"></a><strong>1. Incl Cpu Time</strong></h4><p>define <strong>inclusive</strong> ： 全包括的</p>
<p>上图中可以看到<code>0（toplevel）</code> 的Incl Cpu Time 占了100%的时间，这个不是说100%的时间都是它在执行，请看下面代码：</p>
<pre><code>public void top() {
    a();
    b();
    c();
    d();
}
</code></pre><p>Incl Cpu Time表示方法top执行的总时间，假如说方法top的执行时间为10ms，方法a执行了1ms，方法b执行了2ms，方法c执行了3ms，方法d执行了4ms（这里是为了举个栗子，实际情况中方法a、b、c、d的执行总时间肯定比方法top的执行总时间要小一点）。</p>
<p>而且调用方法top的方法的执行时间是100ms，那么：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>Incl Cpu Time</th>
</tr>
</thead>
<tbody>
<tr>
<td>top</td>
<td></td>
<td>10%</td>
</tr>
<tr>
<td></td>
<td>a</td>
<td>10%</td>
</tr>
<tr>
<td></td>
<td>b</td>
<td>20%</td>
</tr>
<tr>
<td></td>
<td>c</td>
<td>30%</td>
</tr>
<tr>
<td></td>
<td>d</td>
<td>40%</td>
</tr>
</tbody>
</table>
<p>从上面图中可以看到：<br><code>toplevel</code>的 Incl Cpu Time 是1110.943，而<code>io.bxbxbai.android.examples.activity.ExpandableLayoutMainActivity$SimpleAdapter.getItemView</code>方法的Incl Cpu Time为12.859，说明后者的Incl Cpu Time % 约为1.2%</p>
<p>这个指标表示 <span style="color:red"> <strong>这个方法以及这个方法的子方法（比如top方法中的a、b、c、d方法）一共执行的时间</strong></span></p>
<h4 id="2-Excl-Cpu-Time"><a href="#2-Excl-Cpu-Time" class="headerlink" title="2. Excl Cpu Time"></a><strong>2. Excl Cpu Time</strong></h4><p>理解了Incl Cpu Time以后就可以很好理解Excl Cpu Time了，还是上面top方法的栗子：</p>
<p>方法top 的 Incl Cpu Time 减去 方法a、b、c、d的Incl Cpu Time 的时间就是方法top的Excl Cpu Time 了</p>
<h4 id="3-Incl-Real-Time"><a href="#3-Incl-Real-Time" class="headerlink" title="3. Incl Real Time"></a><strong>3. Incl Real Time</strong></h4><p>这个感觉和Incl Cpu Time 差不多，第7条会讲到。</p>
<h4 id="4-Excl-Real-Time"><a href="#4-Excl-Real-Time" class="headerlink" title="4. Excl Real Time"></a><strong>4. Excl Real Time</strong></h4><p>同上</p>
<h4 id="5-Calls-Recur-Calls-Total"><a href="#5-Calls-Recur-Calls-Total" class="headerlink" title="5. Calls + Recur Calls / Total "></a><strong>5. Calls + Recur Calls / Total </strong></h4><p>这个指标非常重要！</p>
<p><strong>它表示这个方法执行的次数</strong>，这个指标中有两个值，一个Call表示这个方法调用的次数，Recur Call表示递归调用次数，看下图：</p>
<p><img src="http://bxbxbai.github.io/img/trace_view_recur_call.png" alt="Recur"></p>
<p>我选中了一个方法，可以看到这个方法的<code>Calls + Recur Calls</code> 值是14 + 0，表示这个方法调用了14次，但是没有递归调用</p>
<p>从Children这一块来看，很多方法调用都是13的倍数，说明父方法中有一个判断，但是这不是重点，有些Child方法调用Calls为26，这说明了这些方法被调用了两遍，是不是可能存在重复调用的情况？这些都是可能可以优化性能的地方。</p>
<h4 id="6-Cpu-Time-Call"><a href="#6-Cpu-Time-Call" class="headerlink" title=" 6. Cpu Time / Call "></a><span style="color:red"> <strong>6. Cpu Time / Call </strong></span></h4><p><strong>重点来了！！！！！！！！！！</strong></p>
<p><img src="http://bxbxbai.github.io/img/trace_view_cpu_time.png" alt="cpu time"></p>
<p>这个指标应该说是最重要的，从上图可以看到，133这个方法的调用次数为20次，而它的Incl Cpu Time为12.859ms，那么133方法每一次执行的时间是0.643ms（<strong>133这个方法是<code>SimpleAdapter</code>的<code>getItemView</code>方法</strong>）</p>
<p>对于一个<code>adapter</code>的<code>getView</code>方法来说0.643ms是非常快的（因为这个<code>adapter</code>中只有一个<code>TextView</code>，我为了测试用的）</p>
<p>如果<code>getView</code>方法执行时间很长，那么必然导致列表滑动的时候产生卡顿现象，可以在<code>getView</code>方法的Children方法列表中找到耗时最长的方法，分析出现问题的原因：</p>
<ul>
<li>是因为有过多的计算？</li>
<li>还是因为有读取SD卡的操作？</li>
<li>还是因为<code>adapter</code>中<code>View</code>太复杂了？</li>
<li>还是因为需要有很多判断，设置<code>View</code>的显示还是隐藏</li>
<li>还是因为其他原因…</li>
</ul>
<h4 id="7-Real-Time-Call"><a href="#7-Real-Time-Call" class="headerlink" title="7. Real Time / Call "></a><strong>7. Real Time / Call </strong></h4><p>Real Time 和 Cpu Time 我现在还不太明白它们的区别，我的理解应该是:</p>
<ul>
<li>Cpu Time 应该是某个方法占用CPU的时间</li>
<li>Real Time 应该是这个方法的实际运行时间</li>
</ul>
<p><strong>为什么它们会有区别呢？可能是因为CPU的上下文切换、阻塞、GC等原因方法的实际执行时间要比Cpu Time 要稍微长一点。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>TraceView是一个非常强大的性能分析工具，因为Android 官网对这个工具的使用介绍文档很少，而且一些中文博客中写的也都是抄来抄去，没有讲到底怎么使用。</p>
<p>最近我在做这方面的性能分析，就慢慢琢磨了这么工具的使用，发现非常强大，写下来总结一下。    </p>
<p>Android的性能分析工具还有很多，比如：</p>
<ul>
<li>Eclipse Memory Analyzer Tool 来分析Android app的内存使用</li>
<li>Dump UI Hierarchy for UI Atomator，分析UI层级</li>
<li>systrace</li>
<li>其他</li>
</ul>
<p>下图这一条工具栏中有很多性能分析工具~~~<br><img src="http://bxbxbai.github.io/img/ddms_tools.png" alt="TOOLS"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前面唠叨&quot;&gt;&lt;a href=&quot;#前面唠叨&quot; class=&quot;headerlink&quot; title=&quot;前面唠叨&quot;&gt;&lt;/a&gt;前面唠叨&lt;/h2&gt;&lt;p&gt;最近公司app中有些列表在滑动的时候会有卡顿现象，我就开始着手解决这些问题，解决问题之前首先要分析列表滑动的性能瓶颈在什么地方。因为之前不会正确使用TraceView这个工具，主要是看不懂TraceView界面下方数据指标的值代表什么意思…以前我用&lt;a href=&quot;http://bxbxbai.github.io/2014/08/01/the-stopwatch-class/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;StopWatch&lt;/a&gt;类来分析性能，现在觉得弱爆了…不过有些地方&lt;a href=&quot;http://bxbxbai.github.io/2014/08/01/the-stopwatch-class/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;StopWatch&lt;/a&gt;工具类还是很简单好用的~&lt;/p&gt;
&lt;p&gt;网上可以找了很多博客来介绍这个工具的使用方法，很多都是讲解了一些一些就会的方法，讲一个大概，包括StackOverFlow上我也没有找到很好的讲解TraceView各个数据指标代码什么意思的回答&lt;/p&gt;
&lt;p&gt;因为我要解决列表滑动的卡顿问题，就必须要找到导致卡顿现象的原因，我就在StackOverFlow上找着别人零散的回答慢慢琢磨这个工具的使用方法。现在我学会了，至少能看懂每个指标什么意思，&lt;strong&gt;最后发现这个工具实在太强大了！！！&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://bxbxbai.gitcafe.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
      <category term="开发技巧" scheme="http://bxbxbai.gitcafe.io/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
      <category term="经验" scheme="http://bxbxbai.gitcafe.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>整理一些比较好的Android开发教程</title>
    <link href="http://bxbxbai.gitcafe.io/2014/10/07/android-develop-resource/"/>
    <id>http://bxbxbai.gitcafe.io/2014/10/07/android-develop-resource/</id>
    <published>2014-10-07T15:08:32.000Z</published>
    <updated>2015-12-23T07:30:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>这些都是我在学习Android开发过程中觉得比较好的教程和博客，在这里整理一下，方便自己也方便大家学习使用。</p>
<p>欢迎补充~</p>
<p>##介绍LoaderManager的使用</p>
<ol>
<li><p>Life before Loaders(part 1)<br><a href="http://www.androiddesignpatterns.com/2012/07/loaders-and-loadermanager-background.html" target="_blank" rel="external">http://www.androiddesignpatterns.com/2012/07/loaders-and-loadermanager-background.html</a></p>
</li>
<li><p>Understanding the LoaderManager(part 2)<br><a href="http://www.androiddesignpatterns.com/2012/07/understanding-loadermanager.html" target="_blank" rel="external">http://www.androiddesignpatterns.com/2012/07/understanding-loadermanager.html</a></p>
</li>
<li><p>Implementing Loaders(part 3)<br><a href="http://www.androiddesignpatterns.com/2012/08/implementing-loaders.html" target="_blank" rel="external">http://www.androiddesignpatterns.com/2012/08/implementing-loaders.html</a></p>
</li>
<li><p>Tutorial: AppListLoader(part 4)<br><a href="http://www.androiddesignpatterns.com/2012/09/tutorial-loader-loadermanager.html" target="_blank" rel="external">http://www.androiddesignpatterns.com/2012/09/tutorial-loader-loadermanager.html</a><br><a href="https://github.com/alexjlockwood/AppListLoader" target="_blank" rel="external">https://github.com/alexjlockwood/AppListLoader</a></p>
</li>
<li><p>How to use Loaders in Android<br><a href="http://www.grokkingandroid.com/using-loaders-in-android/" target="_blank" rel="external">http://www.grokkingandroid.com/using-loaders-in-android/</a></p>
</li>
</ol>
<a id="more"></a>
<h2 id="介绍Volley的使用"><a href="#介绍Volley的使用" class="headerlink" title="介绍Volley的使用"></a>介绍Volley的使用</h2><ol>
<li><p>Android库Volley的使用介绍<br><a href="http://bxbxbai.github.io/2014/09/14/android-working-with-volley/" target="_blank" rel="external">http://bxbxbai.github.io/2014/09/14/android-working-with-volley/</a></p>
</li>
<li><p>Android Volley完全解析（博主是Android牛人，博客质量很高！）<br><a href="http://blog.csdn.net/guolin_blog/article/details/17482095" target="_blank" rel="external">http://blog.csdn.net/guolin_blog/article/details/17482095</a> （Android Volley完全解析(一)，初识Volley的基本用法）<br><a href="http://blog.csdn.net/guolin_blog/article/details/17482165" target="_blank" rel="external">http://blog.csdn.net/guolin_blog/article/details/17482165</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/17612763" target="_blank" rel="external">http://blog.csdn.net/guolin_blog/article/details/17612763</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/17656437" target="_blank" rel="external">http://blog.csdn.net/guolin_blog/article/details/17656437</a></p>
</li>
<li><p>Android 官方的Volley使用介绍（看完基本就知道怎么用了）<br>3.1 Transmitting Network Data using Volley<br><a href="http://developer.android.com/training/volley/index.html" target="_blank" rel="external">http://developer.android.com/training/volley/index.html</a><br>3.2 Sending a Simple Request（发送一个简单的request）<br><a href="http://developer.android.com/training/volley/simple.html" target="_blank" rel="external">http://developer.android.com/training/volley/simple.html</a><br>3.3 Setting up a RequestQueue（创建一个请求队列）<br><a href="http://developer.android.com/training/volley/requestqueue.html" target="_blank" rel="external">http://developer.android.com/training/volley/requestqueue.html</a><br>3.4 Making a Standard Request（使用volley自带的request类）<br><a href="http://developer.android.com/training/volley/request.html" target="_blank" rel="external">http://developer.android.com/training/volley/request.html</a><br>3.5 Implementing a Custom Request(创建你自己的request类这里的栗子就是创建一个GsonRequest)<br><a href="http://developer.android.com/training/volley/request-custom.html" target="_blank" rel="external">http://developer.android.com/training/volley/request-custom.html</a><br>3.6 Google I/O 2013，Volley：Fast, Networking in Android(Google IO大会上的演讲，自备梯子)<br><a href="https://www.youtube.com/watch?v=yhv8l9F44qo" target="_blank" rel="external">https://www.youtube.com/watch?v=yhv8l9F44qo</a><br>3.7 使用Volley的一个demo 工程<br><a href="https://github.com/bxbxbai/FeedListViewDemo" target="_blank" rel="external">https://github.com/bxbxbai/FeedListViewDemo</a></p>
</li>
</ol>
<h2 id="Android开发实例"><a href="#Android开发实例" class="headerlink" title="Android开发实例"></a>Android开发实例</h2><ol>
<li><p>Android Working with ActionBar（讲解Actionbar的使用）<br><a href="http://www.androidhive.info/2013/11/android-working-with-action-bar/" target="_blank" rel="external">http://www.androidhive.info/2013/11/android-working-with-action-bar/</a></p>
</li>
<li><p>创建一个类似Hello SMS的菜单<br><a href="http://blog.robinchutaux.com/blog/how-to-create-a-menu-like-hello-sms/" target="_blank" rel="external">http://blog.robinchutaux.com/blog/how-to-create-a-menu-like-hello-sms/</a></p>
</li>
<li><p>一个开源的知乎专栏App<br><a href="https://github.com/bxbxbai/ZhuanLan" target="_blank" rel="external">https://github.com/bxbxbai/ZhuanLan</a></p>
</li>
</ol>
<h2 id="Android-开源项目集合"><a href="#Android-开源项目集合" class="headerlink" title="Android 开源项目集合"></a>Android 开源项目集合</h2><ol>
<li>最流行的Android组件大全（包括工具和教程，UI组件，类库，游戏引擎和H5应用）<br><a href="http://colobu.com/2014/08/15/android-components-collection/" target="_blank" rel="external">http://colobu.com/2014/08/15/android-components-collection/</a><br><a href="http://blog.daimajia.com/android-library-collection/" target="_blank" rel="external">http://blog.daimajia.com/android-library-collection/</a></li>
</ol>
<h2 id="Android-应用性能优化（包含Android-官方文档）"><a href="#Android-应用性能优化（包含Android-官方文档）" class="headerlink" title="Android 应用性能优化（包含Android 官方文档）"></a>Android 应用性能优化（包含Android 官方文档）</h2><ol>
<li><p>Managing Your App’s Memory<br><a href="http://developer.android.com/training/articles/memory.html" target="_blank" rel="external">http://developer.android.com/training/articles/memory.html</a></p>
</li>
<li><p>Performance Tips<br><a href="http://developer.android.com/training/articles/perf-tips.html" target="_blank" rel="external">http://developer.android.com/training/articles/perf-tips.html</a></p>
</li>
<li><p>Improving Layout Performance<br><a href="http://developer.android.com/training/improving-layouts/index.html" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/index.html</a></p>
</li>
<li><p>Sending Operations to Multiple Threads<br><a href="http://developer.android.com/training/multiple-threads/index.html" target="_blank" rel="external">http://developer.android.com/training/multiple-threads/index.html</a></p>
</li>
<li><p>Performance Tuning On Android(作者详细介绍了各种分析Android性能的方法以及优化策略，非常好的一篇博客)<br><a href="http://blog.venmo.com/hf2t3h4x98p5e13z82pl8j66ngcmry/performance-tuning-on-android" target="_blank" rel="external">http://blog.venmo.com/hf2t3h4x98p5e13z82pl8j66ngcmry/performance-tuning-on-android</a></p>
</li>
<li><p>Using Android TraceView<br><a href="http://blog.cindypotvin.com/using-android-traceview-in-eclipse/" target="_blank" rel="external">http://blog.cindypotvin.com/using-android-traceview-in-eclipse/</a></p>
</li>
<li><p>分析你的App内存使用情况<br><a href="https://developer.android.com/tools/debugging/debugging-memory.html" target="_blank" rel="external">https://developer.android.com/tools/debugging/debugging-memory.html</a></p>
</li>
<li><p>Android Performance Case Study<br><a href="http://www.curious-creature.org/2012/12/01/android-performance-case-study/" target="_blank" rel="external">http://www.curious-creature.org/2012/12/01/android-performance-case-study/</a></p>
</li>
</ol>
<h2 id="Android-ContentProvider介绍"><a href="#Android-ContentProvider介绍" class="headerlink" title="Android ContentProvider介绍"></a>Android ContentProvider介绍</h2><ol>
<li><p>Content Provider Basics<br><a href="http://www.grokkingandroid.com/android-tutorial-content-provider-basics/" target="_blank" rel="external">http://www.grokkingandroid.com/android-tutorial-content-provider-basics/</a></p>
</li>
<li><p>Using Content Providers<br><a href="http://www.grokkingandroid.com/android-tutorial-using-content-providers/" target="_blank" rel="external">http://www.grokkingandroid.com/android-tutorial-using-content-providers/</a></p>
</li>
<li><p>Writing your own Content Provider<br><a href="http://www.grokkingandroid.com/android-tutorial-writing-your-own-content-provider/" target="_blank" rel="external">http://www.grokkingandroid.com/android-tutorial-writing-your-own-content-provider/</a></p>
</li>
<li><p>Better Performance with ContentProviderOperation<br><a href="http://www.grokkingandroid.com/better-performance-with-contentprovideroperation/" target="_blank" rel="external">http://www.grokkingandroid.com/better-performance-with-contentprovideroperation/</a></p>
</li>
</ol>
<h2 id="Android-开发经验"><a href="#Android-开发经验" class="headerlink" title="Android 开发经验"></a>Android 开发经验</h2><p>CodePath Android:  <a href="http://guides.codepath.com/android" target="_blank" rel="external">http://guides.codepath.com/android</a></p>
<ol>
<li><p>Working with the TextView<br><a href="http://guides.codepath.com/android/Working-with-the-TextView" target="_blank" rel="external">http://guides.codepath.com/android/Working-with-the-TextView</a></p>
</li>
<li><p>Working with the ImageView<br><a href="http://guides.codepath.com/android/Working-with-the-ImageView" target="_blank" rel="external">http://guides.codepath.com/android/Working-with-the-ImageView</a></p>
</li>
<li><p>Endless Scrolling with AdapterViews（可以无限加载更多的AdapterView，很巧妙的继承了OnScrollListener）<br><a href="http://guides.codepath.com/android/Endless-Scrolling-with-AdapterViews" target="_blank" rel="external">http://guides.codepath.com/android/Endless-Scrolling-with-AdapterViews</a></p>
</li>
<li><p>Android事件传递机制（有栗子，有分析）<br><a href="http://www.infoq.com/cn/articles/android-event-delivery-mechanism" target="_blank" rel="external">http://www.infoq.com/cn/articles/android-event-delivery-mechanism</a></p>
</li>
<li><p>Android Tips Round-Up, Part 5（Android开发技巧）<br><a href="http://blog.danlew.net/2014/05/28/android-tips-round-up-part-5/" target="_blank" rel="external">http://blog.danlew.net/2014/05/28/android-tips-round-up-part-5/</a></p>
</li>
<li><p>Activity和Fragment的生命周期图<br><a href="http://bxbxbai.github.io/img/complete_android_fragment_lifecycle.png" target="_blank" rel="external">http://bxbxbai.github.io/img/complete_android_fragment_lifecycle.png</a></p>
</li>
<li><p>使用GestureDetector（ListView中左右滑动显示菜单也是使用GestureDetector）<br><a href="http://ryanharter.com/blog/2014/10/08/using-gestures/" target="_blank" rel="external">http://ryanharter.com/blog/2014/10/08/using-gestures/</a> （博文中有图片方法缩小的栗子，可能需要梯子）<br><a href="https://github.com/rharter/android-gesture-detectors" target="_blank" rel="external">https://github.com/rharter/android-gesture-detectors</a> （github上使用GestureDetector的一个项目）</p>
</li>
</ol>
<h2 id="Android开发在线工具"><a href="#Android开发在线工具" class="headerlink" title="Android开发在线工具"></a>Android开发在线工具</h2><ol>
<li><p>在线创建Holo主题（Android Holo Colors Generator）<br><a href="http://android-holo-colors.com/" target="_blank" rel="external">http://android-holo-colors.com/</a></p>
</li>
<li><p>在线创建ActionBar样式（Android Action Bar Style Generator）<br><a href="http://jgilfelt.github.io/android-actionbarstylegenerator/" target="_blank" rel="external">http://jgilfelt.github.io/android-actionbarstylegenerator/</a></p>
</li>
<li><p>在线创建Button样式（Android Button Maker）<br><a href="http://angrytools.com/android/button/" target="_blank" rel="external">http://angrytools.com/android/button/</a></p>
</li>
<li><p>SQLite数据加密<br><a href="https://www.zetetic.net/sqlcipher/" target="_blank" rel="external">https://www.zetetic.net/sqlcipher/</a></p>
</li>
<li><p>在线创建Icon资源（包括：Launch Icon，Actionbar和tab icon，Notification Icon等等）<br><a href="http://romannurik.github.io/AndroidAssetStudio/index.html" target="_blank" rel="external">http://romannurik.github.io/AndroidAssetStudio/index.html</a></p>
</li>
<li><p>Device Frame Generator<br><a href="http://f2prateek.com/android-device-frame-generator/" target="_blank" rel="external">http://f2prateek.com/android-device-frame-generator/</a></p>
</li>
<li><p>Android Simple Nine-patch Generator<br><a href="http://romannurik.github.io/AndroidAssetStudio/nine-patches.html" target="_blank" rel="external">http://romannurik.github.io/AndroidAssetStudio/nine-patches.html</a></p>
</li>
<li><p>AndroidDrawableFactory<br><a href="https://github.com/tizionario/AndroidDrawableFactory" target="_blank" rel="external">https://github.com/tizionario/AndroidDrawableFactory</a></p>
</li>
<li><p>Android Layout Resource Binder(根据xml布局文件，生成findViewById 的Java代码)<br><a href="http://android.lineten.net/layout.php" target="_blank" rel="external">http://android.lineten.net/layout.php</a></p>
</li>
<li><p>Android Fragment Code Generator<br><a href="http://techisfun.github.io/pages/android-fragment-generator/" target="_blank" rel="external">http://techisfun.github.io/pages/android-fragment-generator/</a></p>
</li>
<li><p>Android ContentProvider Generator<br><a href="https://github.com/BoD/android-contentprovider-generator" target="_blank" rel="external">https://github.com/BoD/android-contentprovider-generator</a></p>
</li>
<li><p>SelectorChapek for Android（快速生成Select文件）<br><a href="https://github.com/inmite/android-selector-chapek" target="_blank" rel="external">https://github.com/inmite/android-selector-chapek</a></p>
</li>
<li><p>Android开发工具整理<br><a href="https://github.com/inferjay/AndroidDevTools" target="_blank" rel="external">https://github.com/inferjay/AndroidDevTools</a><br><a href="http://www.androiddevtools.cn/" target="_blank" rel="external">http://www.androiddevtools.cn/</a></p>
</li>
</ol>
<h2 id="Android-Design"><a href="#Android-Design" class="headerlink" title="Android Design"></a>Android Design</h2><ol>
<li><p><strong>台湾人翻译的Material Design文档（非常好！）</strong><br><a href="http://wcc723.gitbooks.io/google_design_translate/content/material-design-introduction.html" target="_blank" rel="external">http://wcc723.gitbooks.io/google_design_translate/content/material-design-introduction.html</a></p>
</li>
<li><p>Android Design 非官方文档（中文翻译）<br><a href="http://adchs.github.io/" target="_blank" rel="external">http://adchs.github.io/</a></p>
</li>
<li><p>Google 开源的Material Design Icons<br><a href="http://google.github.io/material-design-icons/" target="_blank" rel="external">http://google.github.io/material-design-icons/</a><br><a href="https://github.com/google/material-design-icons" target="_blank" rel="external">https://github.com/google/material-design-icons</a></p>
</li>
<li><p>Android Desgin规范<br><a href="http://www.androiddesign.tips/" target="_blank" rel="external">http://www.androiddesign.tips/</a><br><a href="http://petrnohejl.github.io/Android-Cheatsheet-For-Graphic-Designers/" target="_blank" rel="external">http://petrnohejl.github.io/Android-Cheatsheet-For-Graphic-Designers/</a></p>
</li>
<li><p>Material Design Center:<br><a href="https://github.com/lightSky/MaterialDesignCenter" target="_blank" rel="external">https://github.com/lightSky/MaterialDesignCenter</a></p>
</li>
</ol>
<h2 id="很不错的Android开源库"><a href="#很不错的Android开源库" class="headerlink" title="很不错的Android开源库"></a>很不错的Android开源库</h2><ol>
<li><p>第一必须是Volley，上面已经列出链接了</p>
</li>
<li><p>Android Asynchronous Http Client（又是一个异步http通信库，也是非常简单好用）<br><a href="http://loopj.com/android-async-http/" target="_blank" rel="external">http://loopj.com/android-async-http/</a></p>
</li>
<li><p>Butter Knife（你再也不需要老是调用findViewById了！！！功能超级强大！！）<br><a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="external">http://jakewharton.github.io/butterknife/</a></p>
</li>
<li><p>Android Smart Image View（可以从Url或者联系人地址簿中加载图片，图片会自动缓存到内存和SD卡上）<br><a href="http://loopj.com/android-smart-image-view/" target="_blank" rel="external">http://loopj.com/android-smart-image-view/</a></p>
</li>
<li><p>Square公司的Android开源项目<br><a href="http://square.github.io/#android" target="_blank" rel="external">http://square.github.io/#android</a></p>
</li>
<li><p>ActiveAndroid项目（SQLite数据的ORM框架）<br><a href="https://github.com/pardom/ActiveAndroid/wiki/Getting-started" target="_blank" rel="external">https://github.com/pardom/ActiveAndroid/wiki/Getting-started</a><br><a href="https://github.com/pardom/ActiveAndroid" target="_blank" rel="external">https://github.com/pardom/ActiveAndroid</a></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这些都是我在学习Android开发过程中觉得比较好的教程和博客，在这里整理一下，方便自己也方便大家学习使用。&lt;/p&gt;
&lt;p&gt;欢迎补充~&lt;/p&gt;
&lt;p&gt;##介绍LoaderManager的使用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Life before Loaders(part 1)&lt;br&gt;&lt;a href=&quot;http://www.androiddesignpatterns.com/2012/07/loaders-and-loadermanager-background.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.androiddesignpatterns.com/2012/07/loaders-and-loadermanager-background.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Understanding the LoaderManager(part 2)&lt;br&gt;&lt;a href=&quot;http://www.androiddesignpatterns.com/2012/07/understanding-loadermanager.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.androiddesignpatterns.com/2012/07/understanding-loadermanager.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Implementing Loaders(part 3)&lt;br&gt;&lt;a href=&quot;http://www.androiddesignpatterns.com/2012/08/implementing-loaders.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.androiddesignpatterns.com/2012/08/implementing-loaders.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Tutorial: AppListLoader(part 4)&lt;br&gt;&lt;a href=&quot;http://www.androiddesignpatterns.com/2012/09/tutorial-loader-loadermanager.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.androiddesignpatterns.com/2012/09/tutorial-loader-loadermanager.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/alexjlockwood/AppListLoader&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/alexjlockwood/AppListLoader&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;How to use Loaders in Android&lt;br&gt;&lt;a href=&quot;http://www.grokkingandroid.com/using-loaders-in-android/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.grokkingandroid.com/using-loaders-in-android/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://bxbxbai.gitcafe.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
      <category term="开发资源" scheme="http://bxbxbai.gitcafe.io/tags/%E5%BC%80%E5%8F%91%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>Android库Volley的使用介绍</title>
    <link href="http://bxbxbai.gitcafe.io/2014/09/14/android-working-with-volley/"/>
    <id>http://bxbxbai.gitcafe.io/2014/09/14/android-working-with-volley/</id>
    <published>2014-09-14T06:48:39.000Z</published>
    <updated>2016-03-12T07:01:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://developer.android.com/training/volley/index.html" target="_blank" rel="external">Android Volley</a> 是Google开发的一个网络lib，可以让你更加简单并且快速的访问网络数据。Volley库的网络请求都是异步的，你不必担心异步处理问题。</p>
<a id="more"></a>
<p>Volley的优点：</p>
<ol>
<li>请求队列和请求优先级</li>
<li>请求Cache和内存管理</li>
<li>扩展性性强</li>
<li>可以取消请求</li>
</ol>
<h2 id="下载和编译volley-jar"><a href="#下载和编译volley-jar" class="headerlink" title="下载和编译volley.jar"></a>下载和编译volley.jar</h2><ul>
<li>需要安装git，ant，android sdk</li>
</ul>
<p>clone代码：<br><code>git clone https://android.googlesource.com/platform/frameworks/volley</code></p>
<ul>
<li>编译jar：<br><code>android update project -p . 
ant jar</code></li>
</ul>
<ul>
<li><p>添加volley.jar到你的项目中</p>
<p><strong><em>不过已经有人将volley的代码放到github上了：</em></strong><br><a href="https://github.com/mcxiaoke/android-volley" target="_blank" rel="external">https://github.com/mcxiaoke/android-volley</a>，你可以使用更加简单的方式来使用volley：</p>
</li>
</ul>
<h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><p>format: jar</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.mcxiaoke.volley&lt;/groupId&gt;
    &lt;artifactId&gt;library&lt;/artifactId&gt;
    &lt;version&gt;1.0.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><hr>
<h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h3><p>format: jar</p>
<p><code>compile &#39;com.mcxiaoke.volley:library:1.0.6&#39;</code></p>
<h2 id="Volley工作原理图"><a href="#Volley工作原理图" class="headerlink" title="Volley工作原理图"></a>Volley工作原理图</h2><p><img src="http://bxbxbai.github.io/img/volley.png" alt="Volley"></p>
<h2 id="创建Volley-单例"><a href="#创建Volley-单例" class="headerlink" title="创建Volley 单例"></a>创建Volley 单例</h2><p>使用volley时，必须要创建一个请求队列<code>RequestQueue</code>，使用请求队列的最佳方式就是将它做成一个单例，整个app使用这么一个请求队列。</p>
<pre><code>public class AppController extends Application {

public static final String TAG = AppController.class
        .getSimpleName();

private RequestQueue mRequestQueue;
private ImageLoader mImageLoader;

private static AppController mInstance;

@Override
public void onCreate() {
    super.onCreate();
    mInstance = this;
}

public static synchronized AppController getInstance() {
    return mInstance;
}

public RequestQueue getRequestQueue() {
    if (mRequestQueue == null) {
        mRequestQueue = Volley.newRequestQueue(getApplicationContext());
    }

    return mRequestQueue;
}

public ImageLoader getImageLoader() {
    getRequestQueue();
    if (mImageLoader == null) {
        mImageLoader = new ImageLoader(this.mRequestQueue,
                new LruBitmapCache());
    }
    return this.mImageLoader;
}

public &lt;T&gt; void addToRequestQueue(Request&lt;T&gt; req, String tag) {
    // set the default tag if tag is empty
    req.setTag(TextUtils.isEmpty(tag) ? TAG : tag);
    getRequestQueue().add(req);
}

public &lt;T&gt; void addToRequestQueue(Request&lt;T&gt; req) {
    req.setTag(TAG);
    getRequestQueue().add(req);
}

public void cancelPendingRequests(Object tag) {
    if (mRequestQueue != null) {
        mRequestQueue.cancelAll(tag);
    }
}
}
</code></pre><p>另外，你还需要一个Cache来存放请求的图片：</p>
<pre><code>public class LruBitmapCache extends LruCache&lt;String, Bitmap&gt; implement ImageCache {
    public static int getDefaultLruCacheSize() {
        final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);
        final int cacheSize = maxMemory / 8;

        return cacheSize;
    }

    public LruBitmapCache() {
        this(getDefaultLruCacheSize());
    }

    public LruBitmapCache(int sizeInKiloBytes) {
        super(sizeInKiloBytes);
    }

    @Override
    protected int sizeOf(String key, Bitmap value) {
        return value.getRowBytes() * value.getHeight() / 1024;
    }

    @Override
    public Bitmap getBitmap(String url) {
        return get(url);
    }

    @Override
    public void putBitmap(String url, Bitmap bitmap) {
        put(url, bitmap);
    }
}
</code></pre><p>别忘记在<code>AndroidManifest.xml</code>文件中添加<code>android.permission.INTERNET</code>权限。</p>
<h2 id="创建Json请求"><a href="#创建Json请求" class="headerlink" title="创建Json请求"></a>创建Json请求</h2><p>volley自带了<code>JsonObjectRequest</code>和<code>JsonArrayRequest</code>分别来处理Json对象请求和Json数据请求（但是voley没有使用gson库写一个GsonRequest，发送一个request，volley直接返回一个java对象，不过我们可以自己写）。</p>
<h3 id="创建json-object请求"><a href="#创建json-object请求" class="headerlink" title="创建json object请求"></a>创建json object请求</h3><p>发送一个请求只要这么简单，创建一个<code>JsonRequest</code>对象，写好response回调接口，并把这个请求放到请求队列中就可以了。<code>JsonArrayRequest</code>也类似。</p>
<pre><code>// Tag used to cancel the request
String tag_json_obj = &quot;json_obj_req&quot;;
String url = &quot;http://api.androidhive.info/volley/person_object.json&quot;;

JsonObjectRequest jsonObjReq = new JsonObjectRequest(Method.GET,url, null,
            new Response.Listener&lt;JSONObject&gt;() {

                @Override
                public void onResponse(JSONObject response) {
                    Log.d(TAG, response.toString());
                }
            }, new Response.ErrorListener() {

                @Override
                public void onErrorResponse(VolleyError error) {
                    VolleyLog.d(TAG, &quot;Error: &quot; + error.getMessage());
                }
            });

// Adding request to request queue
AppController.getInstance().addToRequestQueue(jsonObjReq, tag_json_obj);
</code></pre><h2 id="创建String请求"><a href="#创建String请求" class="headerlink" title="创建String请求"></a>创建String请求</h2><p><code>StringRequest</code>可以用来请求任何string类型的数据：json，xml，文本等等。</p>
<pre><code>// Tag used to cancel the request
String  tag_string_req = &quot;string_req&quot;;

String url = &quot;http://api.androidhive.info/volley/string_response.html&quot;;

ProgressDialog pDialog = new ProgressDialog(this);
pDialog.setMessage(&quot;Loading...&quot;);
pDialog.show();     

StringRequest strReq = new StringRequest(Method.GET,
            url, new Response.Listener&lt;String&gt;() {

                @Override
                public void onResponse(String response) {
                    Log.d(TAG, response.toString());
                    pDialog.hide();

                }
            }, new Response.ErrorListener() {

                @Override
                public void onErrorResponse(VolleyError error) {
                    VolleyLog.d(TAG, &quot;Error: &quot; + error.getMessage());
                    pDialog.hide();
                }
            });

// Adding request to request queue
AppController.getInstance().addToRequestQueue(strReq, tag_string_req);
</code></pre><h2 id="创建POST请求"><a href="#创建POST请求" class="headerlink" title="创建POST请求"></a>创建POST请求</h2><p>上面说的都是GET请求，下面来说一下POST请求，与GET请求不同的是，只要在创建请求的时候将请求类型改为POST请求，并且override <code>Request</code>的getParams方法即可。</p>
<pre><code>// Tag used to cancel the request
String tag_json_obj = &quot;json_obj_req&quot;;

String url = &quot;http://api.androidhive.info/volley/person_object.json&quot;;
ProgressDialog pDialog = new ProgressDialog(this);
pDialog.setMessage(&quot;Loading...&quot;);
pDialog.show();     

    JsonObjectRequest jsonObjReq = new JsonObjectRequest(Method.POST,
            url, null,
            new Response.Listener&lt;JSONObject&gt;() {

                @Override
                public void onResponse(JSONObject response) {
                    Log.d(TAG, response.toString());
                    pDialog.hide();
                }
            }, new Response.ErrorListener() {

                @Override
                public void onErrorResponse(VolleyError error) {
                    VolleyLog.d(TAG, &quot;Error: &quot; + error.getMessage());
                    pDialog.hide();
                }
            }) {

        @Override
        protected Map&lt;String, String&gt; getParams() {
            Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();
            params.put(&quot;name&quot;, &quot;Androidhive&quot;);
            params.put(&quot;email&quot;, &quot;abc@androidhive.info&quot;);
            params.put(&quot;password&quot;, &quot;password123&quot;);

            return params;
        }

    };

// Adding request to request queue
AppController.getInstance().addToRequestQueue(jsonObjReq, tag_json_obj);
</code></pre><h2 id="添加请求头部信息"><a href="#添加请求头部信息" class="headerlink" title="添加请求头部信息"></a>添加请求头部信息</h2><pre><code>// Tag used to cancel the request
String tag_json_obj = &quot;json_obj_req&quot;;

String url = &quot;http://api.androidhive.info/volley/person_object.json&quot;;

ProgressDialog pDialog = new ProgressDialog(this);
pDialog.setMessage(&quot;Loading...&quot;);
pDialog.show();     

JsonObjectRequest jsonObjReq = new JsonObjectRequest(Method.POST,url, null,new Response.Listener&lt;JSONObject&gt;() {
    @Override
    public void onResponse(JSONObject response) {
        Log.d(TAG, response.toString());
        pDialog.hide();
    }
}, new Response.ErrorListener() {
    @Override
    public void onErrorResponse(VolleyError error) {
        VolleyLog.d(TAG, &quot;Error: &quot; + error.getMessage());
        pDialog.hide();
    }
}) {

/**
* Passing some request headers
* */
@Override
public Map&lt;String, String&gt; getHeaders() throws AuthFailureError {
    HashMap&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;();
    headers.put(&quot;Content-Type&quot;, &quot;application/json&quot;);
    headers.put(&quot;apiKey&quot;, &quot;xxxxxxxxxxxxxxx&quot;);
    return headers;
}
};
// Adding request to request queue
AppController.getInstance().addToRequestQueue(jsonObjReq, tag_json_obj);
</code></pre><h2 id="创建Image请求"><a href="#创建Image请求" class="headerlink" title="创建Image请求"></a>创建Image请求</h2><p>Volley库中自带了<code>NetworkImageView</code>类，这个<code>ImageView</code>可以自动使用volley下载图片</p>
<h3 id="用NetworkImageView加载图片"><a href="#用NetworkImageView加载图片" class="headerlink" title="用NetworkImageView加载图片"></a>用<code>NetworkImageView</code>加载图片</h3><p>首先，说明一下，加载图片的原理：</p>
<p><code>NetworkImageView</code>加载图片需要一个ImageLoader和一个图片URL，这个ImageLoader对象需要一个请求队列对象和ImageCahe对象。调用<code>NetworkImageView</code>的setUrl方法后，首先会判断当前ImageView的URL和新传入的URL是否一致，如果相同，就不用再发送http请求了，如果不同，那么就使用ImageLoader对象来发送http请求获取图片。</p>
<pre><code>ImageLoader imageLoader = AppController.getInstance().getImageLoader();
// If you are using NetworkImageView
imgNetWorkView.setImageUrl(Const.URL_IMAGE, imageLoader);
</code></pre><p>加载一个图片只要这么简单~~~</p>
<h3 id="用ImageView来加载图片"><a href="#用ImageView来加载图片" class="headerlink" title="用ImageView来加载图片"></a>用ImageView来加载图片</h3><p>这个过程和<code>NetworkImageView</code>类似</p>
<pre><code>ImageLoader imageLoader = AppController.getInstance().getImageLoader();

// If you are using normal ImageView
imageLoader.get(Const.URL_IMAGE, new ImageListener() {

    @Override
    public void onErrorResponse(VolleyError error) {
        Log.e(TAG, &quot;Image Load Error: &quot; + error.getMessage());
    }

    @Override
    public void onResponse(ImageContainer response, boolean arg1) {
        if (response.getBitmap() != null) {
            // load image into imageview
            imageView.setImageBitmap(response.getBitmap());
        }
    }
});
</code></pre><p>可以再简单一点：</p>
<pre><code>// Loading image with placeholder and error image
imageLoader.get(Const.URL_IMAGE, ImageLoader.getImageListener(imageView, R.drawable.ico_loading, R.drawable.ico_error));
</code></pre><p><code>ImageLoader.getImageListener</code>方法中已经写了一个默认的<code>ImageListener</code>了</p>
<h2 id="Volley-Cache"><a href="#Volley-Cache" class="headerlink" title="Volley Cache"></a>Volley Cache</h2><p>volley中自带了强大的cache机制来管理请求cache，这会减少网络请求次数和用户等待时间。</p>
<h3 id="从请求Cache中加载请求"><a href="#从请求Cache中加载请求" class="headerlink" title="从请求Cache中加载请求"></a>从请求Cache中加载请求</h3><pre><code>Cache cache = AppController.getInstance().getRequestQueue().getCache();
Entry entry = cache.get(url);
if(entry != null){
    try {
        String data = new String(entry.data, &quot;UTF-8&quot;);
        // handle data, like converting it to xml, json, bitmap etc.,
    } catch (UnsupportedEncodingException e) {      
        e.printStackTrace();
        }
    }
}else{
    // Cached response doesn&apos;t exists. Make network call here
}
</code></pre><h3 id="使请求缓存失效"><a href="#使请求缓存失效" class="headerlink" title="使请求缓存失效"></a>使请求缓存失效</h3><p>失效并不意味这删除，Volley还会继续使用缓存的对象直到从服务器上获取到了新的数据，新的数据会覆盖旧的数据。</p>
<pre><code>AppController.getInstance().getRequestQueue().getCache().invalidate(url, true);
</code></pre><h3 id="关闭Cache"><a href="#关闭Cache" class="headerlink" title="关闭Cache"></a>关闭Cache</h3><p>如果你想将某一个请求的Cache功能关闭，直接调用<code>Request</code>的setShouldCache()方法就可以：</p>
<pre><code>// String request
StringRequest stringReq = new StringRequest(....);

// disable cache
stringReq.setShouldCache(false);
</code></pre><h3 id="将某一URL的Cache删除"><a href="#将某一URL的Cache删除" class="headerlink" title="将某一URL的Cache删除"></a>将某一URL的Cache删除</h3><p>调用<code>Cache</code>的<code>remove</code>方法可以删除这个URL的cache:</p>
<pre><code>AppController.getInstance().getRequestQueue().getCache().remove(url);
</code></pre><h3 id="删除所有的Cache"><a href="#删除所有的Cache" class="headerlink" title="删除所有的Cache"></a>删除所有的Cache</h3><pre><code>AppController.getInstance().getRequestQueue().getCache().clear();
</code></pre><h2 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h2><p>在你添加一个请求到请求队列中的时候，你可以发现，<code>addToRequestQueue(request, tag)</code>方法还接受一个tag参数，这个tag就是用来标记某一类请求的，这样就可以取消这个tag的所有请求了：</p>
<pre><code>String tag_json_arry = &quot;json_req&quot;;
ApplicationController.getInstance().getRequestQueue().cancelAll(&quot;feed_request&quot;);
</code></pre><h2 id="请求优先级"><a href="#请求优先级" class="headerlink" title="请求优先级"></a>请求优先级</h2><p>在创建一个request的时候可以Override <code>Request</code>方法的<code>getPriority</code>方法返回一个优先级，优先级分为：Normal, Low, Immediate, High</p>
<pre><code>private Priority priority = Priority.HIGH;

StringRequest strReq = new StringRequest(Method.GET,
            Const.URL_STRING_REQ, new Response.Listener&lt;String&gt;() {

                @Override
                public void onResponse(String response) {
                    Log.d(TAG, response.toString());
                    msgResponse.setText(response.toString());
                    hideProgressDialog();

                }
            }, new Response.ErrorListener() {

                @Override
                public void onErrorResponse(VolleyError error) {
                    VolleyLog.d(TAG, &quot;Error: &quot; + error.getMessage());
                    hideProgressDialog();
                }
            }) {
        @Override
        public Priority getPriority() {
            return priority;
        }

    };
</code></pre><h2 id="Missing-创建xml请求"><a href="#Missing-创建xml请求" class="headerlink" title="Missing! 创建xml请求"></a>Missing! 创建xml请求</h2><p>就像创建Gson请求一样，你可以自定义一个<code>XMLRequest</code>类来请求xml数据</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://developer.android.com/training/volley/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android Volley&lt;/a&gt; 是Google开发的一个网络lib，可以让你更加简单并且快速的访问网络数据。Volley库的网络请求都是异步的，你不必担心异步处理问题。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://bxbxbai.gitcafe.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
      <category term="开发经验" scheme="http://bxbxbai.gitcafe.io/tags/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="volley" scheme="http://bxbxbai.gitcafe.io/tags/volley/"/>
    
  </entry>
  
  <entry>
    <title>Stopwatch工具类</title>
    <link href="http://bxbxbai.gitcafe.io/2014/08/01/the-stopwatch-class/"/>
    <id>http://bxbxbai.gitcafe.io/2014/08/01/the-stopwatch-class/</id>
    <published>2014-08-01T11:45:01.000Z</published>
    <updated>2015-09-12T07:01:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在我的一部分工作就是优化客户端的性能，比如优化列表快速滑动卡顿现象。</p>
<a id="more"></a>
<p>一个很好的办法就是使用DDMS的Method Profiling功能，它可以生成一个表格来显示app中所有执行的方法的执行时间，占cpu运行的百分比，还有图形化的显示。功能很强大！</p>
<p>但是，有的时候是跨线程工作的，比如，我获得要发送一个http请求到http请求返回时的时间，这个它就无能为力了（或许可能我没有发现这个功能）；还比如，我要获得从sd卡上读一个文件所需的时间。</p>
<p>一个最原始的方法就是</p>
<pre><code>long start = SystemClock.uptimeMillis();
//do something
Log.i(TAG, &quot;time: &quot; + (SystemClock.uptimeMillis() - start));
</code></pre><p>这样就可以获得这段代码的运行时间了，我发现在测试Adapter的<code>getView</code>方法性能时很管用。因为ListView快速滑动时卡顿最主要的原因就是<code>getView</code>方法执行时间过长，我的测试过程中发现<code>getView</code>方法的执行时间不能超过10ms（当然这个在不同手机上运行时间不一样）。也就是如果在一个手机上<code>getView</code>方法执行时间超过10ms，这个列表快速滑动时就会产生卡顿现象。</p>
<p>但是Adapter中可能有很多方法，我要在每个方法中都像上面那样写么？我不要烦死了？</p>
<p>然后，我就从秒表中获得启发，我可不可以也像秒表一样写一个类来对每个方法测试它的运行时间呢？</p>
<p>下面这个类就诞生了，其实这个类很简单，你只需要在你需要测试时间的方法A前写一句：</p>
<pre><code>StopWatch.begin(&quot;bxbxbai&quot;);
</code></pre><p>这就相当于按了一下秒表（StopWatch工具就是在HashMap中添加了一条记录），然后在方法A后面写一句：</p>
<pre><code>StopWatch.end(&quot;bxbxbai&quot;);
</code></pre><p>这就相当于按了一下秒表，系统在Log中输出了方法A的的运行时间，并且把tag删除。</p>
<pre><code>StopWatch.lap(&quot;bxbxbai&quot;);
</code></pre><p>这个方法不会删除tag，它会输出当前时间到打tag的时候的时间间隔，就是秒表的计次功能。</p>
<p>不光如此，这个类还支持跨进程，比如，我在A线程中执行begin方法，我可以在一个Callback中执行end方法，输出总共的执行时间。</p>
<script src="https://gist.github.com/bxbxbai/6278750.js"></script>

]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在我的一部分工作就是优化客户端的性能，比如优化列表快速滑动卡顿现象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
      <category term="开发工具" scheme="http://bxbxbai.gitcafe.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>我如何理解Java中抽象类和接口</title>
    <link href="http://bxbxbai.gitcafe.io/2014/07/20/understood_abstract_class_and_interface/"/>
    <id>http://bxbxbai.gitcafe.io/2014/07/20/understood_abstract_class_and_interface/</id>
    <published>2014-07-20T03:17:42.000Z</published>
    <updated>2016-03-12T06:59:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>在面试中我们经常被问到：<strong>Java中抽象类和接口的区别是什么？</strong></p>
<a id="more"></a>
<p>然后，我们就大说一通抽象类可以有方法，接口不能有实际的方法啦；一个类只能继承一个抽象类，却可以继承多个接口啦，balabala一大堆，就好像把标准答案熟练的说出来一样。</p>
<p><a href="http://www.importnew.com/12399.html" target="_blank" rel="external">抽象类和接口</a>这篇文章讲到了他们的区别和联系，它们确实有很多相似的地方，但是从本质上看，或从语言的设计角度来看，这不是它们最本质的区别。</p>
<h2 id="不卖关子，我个人对这两个的理解："><a href="#不卖关子，我个人对这两个的理解：" class="headerlink" title="不卖关子，我个人对这两个的理解："></a>不卖关子，我个人对这两个的理解：</h2><blockquote>
<p>类是具体实例的抽象，比如一个json字符串的抽象；而抽象类就是类的抽象；接口就是抽象类的抽象，<strong>接口更像是一种协议</strong></p>
</blockquote>
<p>听我慢慢道来~</p>
<h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>首先，我必须吐槽一下这种面试，我认为面试官凡事问出这种类似“说说抽象类和接口的区别”，“说说进程和线程的区别”等等问题，都是不负责的表现。</p>
<p>为什么呢？</p>
<p>一个原因就是，面试官对想要招的人完全没有自己的评价标准，另一个原因就是对面试者不负责。这种问题根本不能考验面试者的水平。</p>
<p>那么，如果我来面试别人，我会问：<strong>请你说说你怎么理解抽象类和接口；如果要你向你外婆解释进程和线程的区别，你会怎么解释？</strong></p>
<p>我觉得这可以考验面试者对问题的理解程度，我想微软的面试题（你如何向你奶奶解释Excel）一样，考验一个人对某一事物的理解程度（虽然，至今我还不能很好的想明白这个问题 -。-）</p>
<h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h2><p>说到抽象类和接口，就必须要说到类。</p>
<p><strong>一个类就是对现实事物的抽象。</strong></p>
<p>比如定义一个BenzCar类，就需要对现实的奔驰汽车有很好的抽象（当然奔驰汽车有好多系列，这里不钻牛角尖）。也就是说如果你要造一辆奔驰汽车，就需要BenzCar这个类（这辆奔驰汽车就是内存中的一个Instance）。</p>
<p><strong>那么抽象类就是对类的抽象。</strong></p>
<p>怎么理解呢？就是说有很多汽车厂商一起定义一种规范（Car类），说要造一辆汽车就需要有发动机，轮胎，音响设备…（这些就相当于抽象方法），具体用什么发动机，轮胎，音响设备由每个汽车厂商自己去完成。这样就有各种汽车了，奔驰牌的，宝马牌的，丰田牌的…</p>
<p><strong>接口就是对抽象类的抽象</strong></p>
<p>这只是我个人的理解。</p>
<p>在我们日常生活中可以看到各种“接口”，电源插座就是一种。开始我是看到耗子叔的博客在开始理解“控制翻转”这个概念的——<a href="http://coolshell.cn/articles/9949.html" target="_blank" rel="external">IoC/DIP其实是一种管理思想| 酷壳- CoolShell.cn</a>。后来我就想，这个东西其实无处不在，制造电源插座的厂和制造电器的厂只要约定一种“接口”——两口插座或三口插座，当然每个国家的接口都不一样，不同接口之间的转换就需要用适配器了。</p>
<p>其实程序中也一样，比如所有的交通工具可以抽象为一个接口<code>Drivable</code>（<em>可能由于经验原因，我考虑的不是很完善</em>），表示实现这个接口的类创建的对象（比如：汽车，飞机，轮船等等）都是可以驾驶的</p>
<pre><code>public interface Drivable{
    public void drive();
}
</code></pre><p>然后，我们就可以创建一个<code>AbstractCar</code>类，表示这个对所有汽车类的一个抽象，所有可以驾驶的汽车都必须继承这个类，这个抽象类中规定了一些抽象方法，比如<code>getEngine()</code>方法，这说明每种汽车的引擎都不太一样，需要在子类中自定义（<em>当然，你也可以继承<code>AbstractCar</code>类，对所有可能具有相同引擎的汽车进行一层抽象</em>）。</p>
<p>为什么对<code>Drivable</code>的<code>drive()</code>方法进行了默认实现，但是默认实现中却直接抛出了异常呢？</p>
<p>其实这是一种实现接口的方法，还有一种方法就是将<code>drive()</code>设为abstract。这两种实现方式，我觉得从功能上讲是一样的，但是从类设计上讲是不同的。</p>
<p>下面代码中的实现，我是参考了<code>java.util.AbstractList&lt;E&gt;</code>中<code>add(int location, E object)</code>方法的设计，它的文档中写到：</p>
<blockquote>
<pre><code>* @throws UnsupportedOperationException
*                if adding to this List is not supported.
</code></pre></blockquote>
<pre><code>public abstract class AbstractCar implements Drivable {
    public abstract Engine getEngine();

    public abstract Wheel getWheel();

    @Override
    public void drive(){
        throw new UnsupportedOperationException();
    }
    // 省略其他方法和属性
}
</code></pre><p>那么上面这段代码中的<code>drive()</code>可以理解为：</p>
<blockquote>
<p>默认情况下“汽车”是不能开的，你实现了一个汽车类后，需要Override这个方法，实现自己的<code>drive</code>方法</p>
</blockquote>
<h2 id="以java容器中的List举例"><a href="#以java容器中的List举例" class="headerlink" title="以java容器中的List举例"></a>以java容器中的List举例</h2><p><img src="http://bxbxbai.github.io/img/full_container_taxonomy.png" alt="Full Container Taxonomy" title="Full Container Taxonomy"></p>
<p>到源码里面找，你就会发现<code>List&lt;E&gt;</code>的继承关系最顶层的就是<code>Iterable</code>，就表示说List是可以<strong>遍历</strong>的，而且它还会产生一个<code>Iterator</code>接口对象。这表示一个列表可以通过这个<strong>迭代器</strong>来遍历。</p>
<p>这就像上面说的，所有的交通工具都是可以<strong>驾驶</strong>的一样，所有的列表都是可以遍历的。</p>
<p>一层一层往下，类就变得更加具体。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>为什么接口可以继承？</p>
<p>其实这个原理很简单。因为总有一个最本质的<strong>协议</strong>来约束大家，比如所有的交通工具都是可以驾驶的，所有的容易都是可以遍历的。然后<strong>协议</strong>会渐渐变得更加具体：</p>
<pre><code>Iterable &lt;- Collection &lt;- List &lt;- AbstractList &lt;- List
</code></pre><p><strong>从下往上看，就是一层比一层抽象。</strong></p>
<p>就像我在文章开头说的，</p>
<ul>
<li>你用<code>ArrayList</code>类可以创建很多个对象，<code>ArrayList</code>就是这些对象的一次抽象</li>
<li>而<code>AbstractList</code>是对<code>ArratList</code>的一次抽象，你用<code>AbstractList</code>可以创建<code>ArrayList</code>，也可以创建<code>Stack</code>，或<code>LinkedList</code>等</li>
<li><code>List</code>接口就是对所有的列表类的抽象</li>
<li><code>Collection</code>就是对所有单一元素的容器的抽象</li>
<li><code>Iterable</code>就是一个最高层次的抽象了，表示所有的容器都是可以遍历的</li>
</ul>
<h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><p>应该有很多我考虑不周全的地方，欢迎大家指正并且讨论</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在面试中我们经常被问到：&lt;strong&gt;Java中抽象类和接口的区别是什么？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://bxbxbai.gitcafe.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Context，什么是Context？</title>
    <link href="http://bxbxbai.gitcafe.io/2014/07/16/context/"/>
    <id>http://bxbxbai.gitcafe.io/2014/07/16/context/</id>
    <published>2014-07-16T12:44:29.000Z</published>
    <updated>2016-03-12T07:02:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="http://www.doubleencore.com/2013/06/context/" target="_blank" rel="external">http://www.doubleencore.com/2013/06/context/</a></p>
<h3 id="译者注："><a href="#译者注：" class="headerlink" title="译者注："></a>译者注：</h3><p>找到一篇好文章，在开发过程中，经常会使用context对象，但是却不知道context是个什么东西，也不知道<code>getApplicationContext()</code> 和 <code>getContext()</code> 如何工作。特地翻译这篇文章，刚开始翻译，英语也不好，有错误还请大家指正。</p>
<a id="more"></a>
<h3 id="译文："><a href="#译文：" class="headerlink" title="译文："></a>译文：</h3><blockquote>
<p><code>Context</code>应该是Android应用开发中最常使用的元素吧？它也应该是最滥用的元素。</p>
</blockquote>
<p><code>Context</code>对象是最常见的对象，经常用于参数传递，因此也会出现一些你意想不到的情况。加载资源文件，启动一个新的<code>Activit</code>y，获取一个系统服务，获取内部文件路径和创建view全部（这些仅仅是一部分）都需要一个<code>Context</code>对象来完成这些操作。我们想做的是给你展示<code>Context</code>如何工作，以及提供一些建议会（希望会）让你在开发中更合理的使用<code>Context</code>。</p>
<h2 id="Context类型"><a href="#Context类型" class="headerlink" title="Context类型"></a>Context类型</h2><p>并不是所有的Context对象都相同，根据Android应用组件的不同，可以分为以下几种：</p>
<p><strong>Application</strong>：它是应用程序的一个单例，它可以通过Activity或Service的<code>getApplication()</code>方法获取，也可以在任何继承<code>Context</code>类的的对象中通过<code>getApplicationContext()</code>来获取。不管它是怎么获取的，这些方法返回的都是App中同一个实例。</p>
<p><strong>Activity/Service</strong>：它们继承自<code>ContextWrapper</code>，<code>ContextWrapper</code>实现了<code>Context</code>同样的API，但是隐藏了内部<code>Context</code>对象的方法调用，<code>Context</code>也是<code>ContextWrapper</code>的父类。每当系统创建一个<code>Activity</code>或<code>Service</code>对象的时候，它也为它们创建了新的<code>ContextWrapper</code>对象。每个<code>Activity</code>或<code>Service</code>对象，包括他们对应的context对象都是唯一的。</p>
<p><strong>BroadcastReceiver</strong>：它并不拥有<code>Context</code>对象，但是系统在一个新的广播到来的时候通过<code>onReceiver()</code>方法传入一个<code>Context</code>对象，这是一个<code>ReceiverRestrictedContext</code>，它的两个主要方法，<code>registerReceiver()</code>和<code>bindService()</code>都被禁用了。每一次receiver处理一个广播，传入的Context对象都是一个新的实例。</p>
<p><strong>ContentProvider</strong>：同样也不是一个<code>Context</code>对象，但是在创建的时候会通过<code>getContext()</code>方法传入一个context对象。如果<code>ContentProvider</code>是在本地调用的话（在同一个进程中），那么这会返回一个应用单例。然而，如果是在不同的进程中调用的话，它会新建一个context对象表示当前provider运行的进程。</p>
<h2 id="Saved-References"><a href="#Saved-References" class="headerlink" title="Saved References"></a>Saved References</h2><p>第一个问题是，我们想在一个对象中保存一个Context对象的引用，并且这个对象的生命周期超过了你保存的Context对象。比如：创建一个需要一个Context对象的单例来加载文件资源或访问一个ContentProvider，并且在这个单例中保存当前Activity或Service的引用。</p>
<p><strong>Bad Singleton</strong></p>
<pre><code>public class CustomManager {
    private static CustomManager sInstance;

    public static CustomManager getInstance(Context context) {
        if (sInstance == null) {
            sInstance = new CustomManager(context);
        }

        return sInstance;
    }

    private Context mContext;

    private CustomManager(Context context) {
        mContext = context;
    }
}
</code></pre><p>这里的问题在于，我们并不知道<code>Context</code>从哪里来，并且如果单例保存了<code>Activity</code>或<code>Service</code>的引用，如果它们被销毁了，这样是不安全的。这个问题是因为单例在类里面保存了一个静态引用。这就意味着那个对象，以及这个对象引用的所有对象都不会被gc回收。如果<code>Context</code>对象是一个<code>Activity</code>，我们就会始终持有这个<code>Activity</code>的所有View以及其他可能很大的对象，最终导致内存泄露。</p>
<p>为了防止出现这种情况，我们可以修改这个类让它持有<code>Application Context</code>：</p>
<p><strong>Better Singleton：</strong></p>
<pre><code>public class CustomManager {
    private static CustomManager sInstance;

    public static CustomManager getInstance(Context context) {
        if (sInstance == null) {
            //Always pass in the Application Context
            sInstance = new CustomManager(context.getApplicationContext());
        }

        return sInstance;
    }

    private Context mContext;

    private CustomManager(Context context) {
        mContext = context;
    }
}
</code></pre><p>现在，不管context对象是从哪里传入的，因为现在单例持有的是<code>Application Context</code>，这个是安全的，因为<code>Application Context</code> 本身就是一个单例，因此不会造成内存泄露。还有一个类似的问题就是在一个后台线程（background thread）或一个延时<code>Handler</code>中持有一个对<code>Context</code>的引用。</p>
<p>既然<code>Application Context</code>有那么多好处，我们为什么不用<code>Application Context</code>来处理一切呢？这个问题的答案就是，前面提到过的，是因为</p>
<p><strong>这些Context并不都是相同的</strong>。</p>
<h2 id="Context的作用"><a href="#Context的作用" class="headerlink" title="Context的作用"></a>Context的作用</h2><p>从上文中可以知道，Context有多种来源，而不同来源的Context所具有的通用操作也不一样，下表列出了各种不同Context 的作用域：</p>
<table>
<thead>
<tr>
<th>.</th>
<th style="text-align:center">Application</th>
<th style="text-align:center">Activity</th>
<th style="text-align:center">Service</th>
<th style="text-align:center">ContentProvider</th>
<th style="text-align:center">BroadcastReceiver</th>
</tr>
</thead>
<tbody>
<tr>
<td>Show a Dialog</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td>Start an Activity</td>
<td style="text-align:center">NO<code>1</code></td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO<code>1</code></td>
<td style="text-align:center">NO<code>1</code></td>
<td style="text-align:center">NO<code>1</code></td>
</tr>
<tr>
<td>Layout Inflation</td>
<td style="text-align:center">NO<code>2</code></td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO<code>2</code></td>
<td style="text-align:center">NO<code>2</code></td>
<td style="text-align:center">NO<code>2</code></td>
</tr>
<tr>
<td>Start a Service</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td>Bind to a Service</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td>Send a Broadcast</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td>Register BroadcastReceiver</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO<code>3</code></td>
</tr>
<tr>
<td>Load Resource Values</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
</tbody>
</table>
<p><strong>译者注</strong>：这1，2，3标注就不翻译了，说说我自己的理解吧。这几个Context只有Activity的Context是“看的见的”，其他组件的Context都是“看不见的”。因此，如果你想创建一个比如Dialog，Activity等“看的见”的组件就必须要用Activity的Context。比如，你想调用getString或getResource方法获取res文件夹下的资源时，所有的Context对象都可以使用。因为这些东西都是“看不见”的。</p>
<p><strong>“Show a Dialog”</strong> 这是我在公司亲身遇到过的一个问题，Dialog必须要依附于一个Activity组件，不然无法显示。</p>
<p><strong>“Start an Activity”</strong>这个与Activity运行的<a href="http://developer.android.com/guide/components/tasks-and-back-stack.html" target="_blank" rel="external">后退栈</a>有关系</p>
<h2 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h2><p>你可以从上面的表格中看到<code>Application Context</code>有很多事情是做不了的，它不能做的事情都与UI有关。事实上，只有Activity才能够处理与UI有关的任务，其他的Context都是非常相似的（不能处理与UI有关的任务）。</p>
<p>这3个任务（“Show a Dialog”，“Start a Activity”，“Layout Inflation”）似乎就是Android系统就是这么设计的，让Activity来处理这些与UI有关的任务。想要使用Application Context对象来新建一个Dialog或者启动一个Activity系统就会抛出异常，然后程序就会崩溃。</p>
<p>Infalting layouts是一个容易被忽略的问题，如果你读过这篇文章<a href="http://www.doubleencore.com/2013/05/layout-inflation-as-intended/" target="_blank" rel="external">layout inflation</a>，你就会明白这里面隐藏着一些坑…使用不同的Context就是会带你走向不同坑。当你使用<em>LayoutInflator</em>，并且使用<code>Application Context</code>后，它会返回一个<code>View</code>，但是这个<code>View</code>的主题和样式就会被忽略。这是因为，<code>Activity</code> 才是系统配置文件中的唯一持有主题和样式的<code>Contex</code>t。其他所有的<code>Context</code>都会使用系统默认的主题来渲染你的xml来生成<code>View</code>，最终就导致了界面并不是你想要的。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>很多情况下，你可以在一个组件内部使用Context对象，你可以很安全的持有Context的引用，前提就是你的对象生命周期小于Context的生命周期。如果你的对象需要持有一个比Context生命周期要长的Context引用时，即使你的对象也是一个临时对象，也请你考虑保存Application Context 的引用！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;http://www.doubleencore.com/2013/06/context/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.doubleencore.com/2013/06/context/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;译者注：&quot;&gt;&lt;a href=&quot;#译者注：&quot; class=&quot;headerlink&quot; title=&quot;译者注：&quot;&gt;&lt;/a&gt;译者注：&lt;/h3&gt;&lt;p&gt;找到一篇好文章，在开发过程中，经常会使用context对象，但是却不知道context是个什么东西，也不知道&lt;code&gt;getApplicationContext()&lt;/code&gt; 和 &lt;code&gt;getContext()&lt;/code&gt; 如何工作。特地翻译这篇文章，刚开始翻译，英语也不好，有错误还请大家指正。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://bxbxbai.gitcafe.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
      <category term="翻译" scheme="http://bxbxbai.gitcafe.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>
